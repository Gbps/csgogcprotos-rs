// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `base_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default)]
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    item_def_id: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    cost_in_local_currency: ::std::option::Option<u32>,
    purchase_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;


    pub fn get_item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }
    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;


    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;


    pub fn get_cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }
    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;


    pub fn get_purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }
    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCStorePurchaseInit_LineItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cost_in_local_currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.purchase_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_id",
                |m: &CGCStorePurchaseInit_LineItem| { &m.item_def_id },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.item_def_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quantity",
                |m: &CGCStorePurchaseInit_LineItem| { &m.quantity },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cost_in_local_currency",
                |m: &CGCStorePurchaseInit_LineItem| { &m.cost_in_local_currency },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.cost_in_local_currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "purchase_type",
                |m: &CGCStorePurchaseInit_LineItem| { &m.purchase_type },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.purchase_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCStorePurchaseInit_LineItem>(
                "CGCStorePurchaseInit_LineItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: ::protobuf::rt::LazyV2<CGCStorePurchaseInit_LineItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCStorePurchaseInit_LineItem::new)
    }
}

impl ::protobuf::Clear for CGCStorePurchaseInit_LineItem {
    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCStorePurchaseInit_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStorePurchaseInit_LineItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseInit {
    // message fields
    country: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    pub line_items: ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;


    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // repeated .CGCStorePurchaseInit_LineItem line_items = 4;


    pub fn get_line_items(&self) -> &[CGCStorePurchaseInit_LineItem] {
        &self.line_items
    }
    pub fn clear_line_items(&mut self) {
        self.line_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_line_items(&mut self, v: ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem>) {
        self.line_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_line_items(&mut self) -> &mut ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem> {
        &mut self.line_items
    }

    // Take field
    pub fn take_line_items(&mut self) -> ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem> {
        ::std::mem::replace(&mut self.line_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInit {
    fn is_initialized(&self) -> bool {
        for v in &self.line_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.line_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &CMsgGCStorePurchaseInit| { &m.country },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CMsgGCStorePurchaseInit| { &m.language },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency",
                |m: &CMsgGCStorePurchaseInit| { &m.currency },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGCStorePurchaseInit_LineItem>>(
                "line_items",
                |m: &CMsgGCStorePurchaseInit| { &m.line_items },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.line_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseInit>(
                "CMsgGCStorePurchaseInit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseInit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseInit::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseInit {
    fn clear(&mut self) {
        self.country.clear();
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    result: ::std::option::Option<i32>,
    txn_id: ::std::option::Option<u64>,
    url: ::protobuf::SingularField<::std::string::String>,
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    // optional string url = 3;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint64 item_ids = 4;


    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }
    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.txn_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.url },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_ids",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.item_ids },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.item_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseInitResponse>(
                "CMsgGCStorePurchaseInitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseInitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseInitResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseInitResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.url.clear();
        self.item_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOPartyInvite {
    // message fields
    group_id: ::std::option::Option<u64>,
    sender_id: ::std::option::Option<u64>,
    sender_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOPartyInvite {
    fn default() -> &'a CSOPartyInvite {
        <CSOPartyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOPartyInvite {
    pub fn new() -> CSOPartyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;


    pub fn get_group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;


    pub fn get_sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }
    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;


    pub fn get_sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sender_name(&mut self) {
        self.sender_name.clear();
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name.set_default();
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOPartyInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sender_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sender_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sender_id {
            my_size += 9;
        }
        if let Some(ref v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.sender_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOPartyInvite {
        CSOPartyInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "group_id",
                |m: &CSOPartyInvite| { &m.group_id },
                |m: &mut CSOPartyInvite| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sender_id",
                |m: &CSOPartyInvite| { &m.sender_id },
                |m: &mut CSOPartyInvite| { &mut m.sender_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender_name",
                |m: &CSOPartyInvite| { &m.sender_name },
                |m: &mut CSOPartyInvite| { &mut m.sender_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOPartyInvite>(
                "CSOPartyInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOPartyInvite {
        static instance: ::protobuf::rt::LazyV2<CSOPartyInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOPartyInvite::new)
    }
}

impl ::protobuf::Clear for CSOPartyInvite {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOPartyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPartyInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOLobbyInvite {
    // message fields
    group_id: ::std::option::Option<u64>,
    sender_id: ::std::option::Option<u64>,
    sender_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOLobbyInvite {
    fn default() -> &'a CSOLobbyInvite {
        <CSOLobbyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOLobbyInvite {
    pub fn new() -> CSOLobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;


    pub fn get_group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;


    pub fn get_sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }
    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;


    pub fn get_sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sender_name(&mut self) {
        self.sender_name.clear();
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name.set_default();
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOLobbyInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sender_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sender_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sender_id {
            my_size += 9;
        }
        if let Some(ref v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.sender_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOLobbyInvite {
        CSOLobbyInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "group_id",
                |m: &CSOLobbyInvite| { &m.group_id },
                |m: &mut CSOLobbyInvite| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sender_id",
                |m: &CSOLobbyInvite| { &m.sender_id },
                |m: &mut CSOLobbyInvite| { &mut m.sender_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender_name",
                |m: &CSOLobbyInvite| { &m.sender_name },
                |m: &mut CSOLobbyInvite| { &mut m.sender_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOLobbyInvite>(
                "CSOLobbyInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOLobbyInvite {
        static instance: ::protobuf::rt::LazyV2<CSOLobbyInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOLobbyInvite::new)
    }
}

impl ::protobuf::Clear for CSOLobbyInvite {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOLobbyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOLobbyInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSystemBroadcast {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSystemBroadcast {
    fn default() -> &'a CMsgSystemBroadcast {
        <CMsgSystemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemBroadcast {
    pub fn new() -> CMsgSystemBroadcast {
        ::std::default::Default::default()
    }

    // optional string message = 1;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSystemBroadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSystemBroadcast {
        CMsgSystemBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgSystemBroadcast| { &m.message },
                |m: &mut CMsgSystemBroadcast| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSystemBroadcast>(
                "CMsgSystemBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSystemBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgSystemBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSystemBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgSystemBroadcast {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSystemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSystemBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgInviteToParty {
    // message fields
    steam_id: ::std::option::Option<u64>,
    client_version: ::std::option::Option<u32>,
    team_invite: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToParty {
    fn default() -> &'a CMsgInviteToParty {
        <CMsgInviteToParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToParty {
    pub fn new() -> CMsgInviteToParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_invite = 3;


    pub fn get_team_invite(&self) -> u32 {
        self.team_invite.unwrap_or(0)
    }
    pub fn clear_team_invite(&mut self) {
        self.team_invite = ::std::option::Option::None;
    }

    pub fn has_team_invite(&self) -> bool {
        self.team_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_invite(&mut self, v: u32) {
        self.team_invite = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgInviteToParty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_invite = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_invite {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_invite {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgInviteToParty {
        CMsgInviteToParty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgInviteToParty| { &m.steam_id },
                |m: &mut CMsgInviteToParty| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &CMsgInviteToParty| { &m.client_version },
                |m: &mut CMsgInviteToParty| { &mut m.client_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team_invite",
                |m: &CMsgInviteToParty| { &m.team_invite },
                |m: &mut CMsgInviteToParty| { &mut m.team_invite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgInviteToParty>(
                "CMsgInviteToParty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgInviteToParty {
        static instance: ::protobuf::rt::LazyV2<CMsgInviteToParty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgInviteToParty::new)
    }
}

impl ::protobuf::Clear for CMsgInviteToParty {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_invite = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgInviteToParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInviteToParty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgInvitationCreated {
    // message fields
    group_id: ::std::option::Option<u64>,
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgInvitationCreated {
    fn default() -> &'a CMsgInvitationCreated {
        <CMsgInvitationCreated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInvitationCreated {
    pub fn new() -> CMsgInvitationCreated {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;


    pub fn get_group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 2;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgInvitationCreated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgInvitationCreated {
        CMsgInvitationCreated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "group_id",
                |m: &CMsgInvitationCreated| { &m.group_id },
                |m: &mut CMsgInvitationCreated| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgInvitationCreated| { &m.steam_id },
                |m: &mut CMsgInvitationCreated| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgInvitationCreated>(
                "CMsgInvitationCreated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgInvitationCreated {
        static instance: ::protobuf::rt::LazyV2<CMsgInvitationCreated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgInvitationCreated::new)
    }
}

impl ::protobuf::Clear for CMsgInvitationCreated {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgInvitationCreated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInvitationCreated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyInviteResponse {
    // message fields
    party_id: ::std::option::Option<u64>,
    accept: ::std::option::Option<bool>,
    client_version: ::std::option::Option<u32>,
    team_invite: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInviteResponse {
    fn default() -> &'a CMsgPartyInviteResponse {
        <CMsgPartyInviteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInviteResponse {
    pub fn new() -> CMsgPartyInviteResponse {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;


    pub fn get_accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }
    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_invite = 4;


    pub fn get_team_invite(&self) -> u32 {
        self.team_invite.unwrap_or(0)
    }
    pub fn clear_team_invite(&mut self) {
        self.team_invite = ::std::option::Option::None;
    }

    pub fn has_team_invite(&self) -> bool {
        self.team_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_invite(&mut self, v: u32) {
        self.team_invite = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyInviteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.accept = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_invite = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accept {
            my_size += 2;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_invite {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.team_invite {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyInviteResponse {
        CMsgPartyInviteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "party_id",
                |m: &CMsgPartyInviteResponse| { &m.party_id },
                |m: &mut CMsgPartyInviteResponse| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "accept",
                |m: &CMsgPartyInviteResponse| { &m.accept },
                |m: &mut CMsgPartyInviteResponse| { &mut m.accept },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &CMsgPartyInviteResponse| { &m.client_version },
                |m: &mut CMsgPartyInviteResponse| { &mut m.client_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team_invite",
                |m: &CMsgPartyInviteResponse| { &m.team_invite },
                |m: &mut CMsgPartyInviteResponse| { &mut m.team_invite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyInviteResponse>(
                "CMsgPartyInviteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyInviteResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyInviteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyInviteResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyInviteResponse {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_invite = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyInviteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyInviteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgKickFromParty {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgKickFromParty {
    fn default() -> &'a CMsgKickFromParty {
        <CMsgKickFromParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKickFromParty {
    pub fn new() -> CMsgKickFromParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKickFromParty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgKickFromParty {
        CMsgKickFromParty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgKickFromParty| { &m.steam_id },
                |m: &mut CMsgKickFromParty| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgKickFromParty>(
                "CMsgKickFromParty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgKickFromParty {
        static instance: ::protobuf::rt::LazyV2<CMsgKickFromParty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgKickFromParty::new)
    }
}

impl ::protobuf::Clear for CMsgKickFromParty {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgKickFromParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKickFromParty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeaveParty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveParty {
    fn default() -> &'a CMsgLeaveParty {
        <CMsgLeaveParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveParty {
    pub fn new() -> CMsgLeaveParty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgLeaveParty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLeaveParty {
        CMsgLeaveParty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLeaveParty>(
                "CMsgLeaveParty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLeaveParty {
        static instance: ::protobuf::rt::LazyV2<CMsgLeaveParty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLeaveParty::new)
    }
}

impl ::protobuf::Clear for CMsgLeaveParty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeaveParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaveParty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerAvailable {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgServerAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgServerAvailable>(
                "CMsgServerAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: ::protobuf::rt::LazyV2<CMsgServerAvailable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgServerAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgServerAvailable {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLANServerAvailable {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLANServerAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "lobby_id",
                |m: &CMsgLANServerAvailable| { &m.lobby_id },
                |m: &mut CMsgLANServerAvailable| { &mut m.lobby_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLANServerAvailable>(
                "CMsgLANServerAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: ::protobuf::rt::LazyV2<CMsgLANServerAvailable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLANServerAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgLANServerAvailable {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLANServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLANServerAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconGameAccountClient {
    // message fields
    additional_backpack_slots: ::std::option::Option<u32>,
    bonus_xp_timestamp_refresh: ::std::option::Option<u32>,
    bonus_xp_usedflags: ::std::option::Option<u32>,
    elevated_state: ::std::option::Option<u32>,
    elevated_timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;


    pub fn get_additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }
    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional fixed32 bonus_xp_timestamp_refresh = 12;


    pub fn get_bonus_xp_timestamp_refresh(&self) -> u32 {
        self.bonus_xp_timestamp_refresh.unwrap_or(0)
    }
    pub fn clear_bonus_xp_timestamp_refresh(&mut self) {
        self.bonus_xp_timestamp_refresh = ::std::option::Option::None;
    }

    pub fn has_bonus_xp_timestamp_refresh(&self) -> bool {
        self.bonus_xp_timestamp_refresh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_xp_timestamp_refresh(&mut self, v: u32) {
        self.bonus_xp_timestamp_refresh = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_xp_usedflags = 13;


    pub fn get_bonus_xp_usedflags(&self) -> u32 {
        self.bonus_xp_usedflags.unwrap_or(0)
    }
    pub fn clear_bonus_xp_usedflags(&mut self) {
        self.bonus_xp_usedflags = ::std::option::Option::None;
    }

    pub fn has_bonus_xp_usedflags(&self) -> bool {
        self.bonus_xp_usedflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_xp_usedflags(&mut self, v: u32) {
        self.bonus_xp_usedflags = ::std::option::Option::Some(v);
    }

    // optional uint32 elevated_state = 14;


    pub fn get_elevated_state(&self) -> u32 {
        self.elevated_state.unwrap_or(0)
    }
    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: u32) {
        self.elevated_state = ::std::option::Option::Some(v);
    }

    // optional uint32 elevated_timestamp = 15;


    pub fn get_elevated_timestamp(&self) -> u32 {
        self.elevated_timestamp.unwrap_or(0)
    }
    pub fn clear_elevated_timestamp(&mut self) {
        self.elevated_timestamp = ::std::option::Option::None;
    }

    pub fn has_elevated_timestamp(&self) -> bool {
        self.elevated_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_timestamp(&mut self, v: u32) {
        self.elevated_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconGameAccountClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.additional_backpack_slots = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.bonus_xp_timestamp_refresh = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_xp_usedflags = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.elevated_state = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.elevated_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_xp_timestamp_refresh {
            my_size += 5;
        }
        if let Some(v) = self.bonus_xp_usedflags {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.elevated_state {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.elevated_timestamp {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bonus_xp_timestamp_refresh {
            os.write_fixed32(12, v)?;
        }
        if let Some(v) = self.bonus_xp_usedflags {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.elevated_timestamp {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "additional_backpack_slots",
                |m: &CSOEconGameAccountClient| { &m.additional_backpack_slots },
                |m: &mut CSOEconGameAccountClient| { &mut m.additional_backpack_slots },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "bonus_xp_timestamp_refresh",
                |m: &CSOEconGameAccountClient| { &m.bonus_xp_timestamp_refresh },
                |m: &mut CSOEconGameAccountClient| { &mut m.bonus_xp_timestamp_refresh },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bonus_xp_usedflags",
                |m: &CSOEconGameAccountClient| { &m.bonus_xp_usedflags },
                |m: &mut CSOEconGameAccountClient| { &mut m.bonus_xp_usedflags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "elevated_state",
                |m: &CSOEconGameAccountClient| { &m.elevated_state },
                |m: &mut CSOEconGameAccountClient| { &mut m.elevated_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "elevated_timestamp",
                |m: &CSOEconGameAccountClient| { &m.elevated_timestamp },
                |m: &mut CSOEconGameAccountClient| { &mut m.elevated_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconGameAccountClient>(
                "CSOEconGameAccountClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: ::protobuf::rt::LazyV2<CSOEconGameAccountClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconGameAccountClient::new)
    }
}

impl ::protobuf::Clear for CSOEconGameAccountClient {
    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.bonus_xp_timestamp_refresh = ::std::option::Option::None;
        self.bonus_xp_usedflags = ::std::option::Option::None;
        self.elevated_state = ::std::option::Option::None;
        self.elevated_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemCriteriaCondition {
    // message fields
    op: ::std::option::Option<i32>,
    field: ::protobuf::SingularField<::std::string::String>,
    required: ::std::option::Option<bool>,
    float_value: ::std::option::Option<f32>,
    string_value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteriaCondition {
    fn default() -> &'a CSOItemCriteriaCondition {
        <CSOItemCriteriaCondition as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteriaCondition {
    pub fn new() -> CSOItemCriteriaCondition {
        ::std::default::Default::default()
    }

    // optional int32 op = 1;


    pub fn get_op(&self) -> i32 {
        self.op.unwrap_or(0)
    }
    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    // optional string field = 2;


    pub fn get_field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool required = 3;


    pub fn get_required(&self) -> bool {
        self.required.unwrap_or(false)
    }
    pub fn clear_required(&mut self) {
        self.required = ::std::option::Option::None;
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = ::std::option::Option::Some(v);
    }

    // optional float float_value = 4;


    pub fn get_float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }
    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;


    pub fn get_string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.string_value.clear();
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value.set_default();
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOItemCriteriaCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.op = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_value = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.required {
            my_size += 2;
        }
        if let Some(v) = self.float_value {
            my_size += 5;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.field.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(4, v)?;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemCriteriaCondition {
        CSOItemCriteriaCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "op",
                |m: &CSOItemCriteriaCondition| { &m.op },
                |m: &mut CSOItemCriteriaCondition| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "field",
                |m: &CSOItemCriteriaCondition| { &m.field },
                |m: &mut CSOItemCriteriaCondition| { &mut m.field },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "required",
                |m: &CSOItemCriteriaCondition| { &m.required },
                |m: &mut CSOItemCriteriaCondition| { &mut m.required },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_value",
                |m: &CSOItemCriteriaCondition| { &m.float_value },
                |m: &mut CSOItemCriteriaCondition| { &mut m.float_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_value",
                |m: &CSOItemCriteriaCondition| { &m.string_value },
                |m: &mut CSOItemCriteriaCondition| { &mut m.string_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemCriteriaCondition>(
                "CSOItemCriteriaCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemCriteriaCondition {
        static instance: ::protobuf::rt::LazyV2<CSOItemCriteriaCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemCriteriaCondition::new)
    }
}

impl ::protobuf::Clear for CSOItemCriteriaCondition {
    fn clear(&mut self) {
        self.op = ::std::option::Option::None;
        self.field.clear();
        self.required = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.string_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemCriteriaCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteriaCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemCriteria {
    // message fields
    item_level: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<i32>,
    item_level_set: ::std::option::Option<bool>,
    item_quality_set: ::std::option::Option<bool>,
    initial_inventory: ::std::option::Option<u32>,
    initial_quantity: ::std::option::Option<u32>,
    ignore_enabled_flag: ::std::option::Option<bool>,
    pub conditions: ::protobuf::RepeatedField<CSOItemCriteriaCondition>,
    item_rarity: ::std::option::Option<i32>,
    item_rarity_set: ::std::option::Option<bool>,
    recent_only: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteria {
    fn default() -> &'a CSOItemCriteria {
        <CSOItemCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteria {
    pub fn new() -> CSOItemCriteria {
        ::std::default::Default::default()
    }

    // optional uint32 item_level = 1;


    pub fn get_item_level(&self) -> u32 {
        self.item_level.unwrap_or(0)
    }
    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: u32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 item_quality = 2;


    pub fn get_item_quality(&self) -> i32 {
        self.item_quality.unwrap_or(0)
    }
    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: i32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional bool item_level_set = 3;


    pub fn get_item_level_set(&self) -> bool {
        self.item_level_set.unwrap_or(false)
    }
    pub fn clear_item_level_set(&mut self) {
        self.item_level_set = ::std::option::Option::None;
    }

    pub fn has_item_level_set(&self) -> bool {
        self.item_level_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level_set(&mut self, v: bool) {
        self.item_level_set = ::std::option::Option::Some(v);
    }

    // optional bool item_quality_set = 4;


    pub fn get_item_quality_set(&self) -> bool {
        self.item_quality_set.unwrap_or(false)
    }
    pub fn clear_item_quality_set(&mut self) {
        self.item_quality_set = ::std::option::Option::None;
    }

    pub fn has_item_quality_set(&self) -> bool {
        self.item_quality_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality_set(&mut self, v: bool) {
        self.item_quality_set = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_inventory = 5;


    pub fn get_initial_inventory(&self) -> u32 {
        self.initial_inventory.unwrap_or(0)
    }
    pub fn clear_initial_inventory(&mut self) {
        self.initial_inventory = ::std::option::Option::None;
    }

    pub fn has_initial_inventory(&self) -> bool {
        self.initial_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_inventory(&mut self, v: u32) {
        self.initial_inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_quantity = 6;


    pub fn get_initial_quantity(&self) -> u32 {
        self.initial_quantity.unwrap_or(0)
    }
    pub fn clear_initial_quantity(&mut self) {
        self.initial_quantity = ::std::option::Option::None;
    }

    pub fn has_initial_quantity(&self) -> bool {
        self.initial_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_quantity(&mut self, v: u32) {
        self.initial_quantity = ::std::option::Option::Some(v);
    }

    // optional bool ignore_enabled_flag = 8;


    pub fn get_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.unwrap_or(false)
    }
    pub fn clear_ignore_enabled_flag(&mut self) {
        self.ignore_enabled_flag = ::std::option::Option::None;
    }

    pub fn has_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_enabled_flag(&mut self, v: bool) {
        self.ignore_enabled_flag = ::std::option::Option::Some(v);
    }

    // repeated .CSOItemCriteriaCondition conditions = 9;


    pub fn get_conditions(&self) -> &[CSOItemCriteriaCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteriaCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteriaCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteriaCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // optional int32 item_rarity = 10;


    pub fn get_item_rarity(&self) -> i32 {
        self.item_rarity.unwrap_or(0)
    }
    pub fn clear_item_rarity(&mut self) {
        self.item_rarity = ::std::option::Option::None;
    }

    pub fn has_item_rarity(&self) -> bool {
        self.item_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity(&mut self, v: i32) {
        self.item_rarity = ::std::option::Option::Some(v);
    }

    // optional bool item_rarity_set = 11;


    pub fn get_item_rarity_set(&self) -> bool {
        self.item_rarity_set.unwrap_or(false)
    }
    pub fn clear_item_rarity_set(&mut self) {
        self.item_rarity_set = ::std::option::Option::None;
    }

    pub fn has_item_rarity_set(&self) -> bool {
        self.item_rarity_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity_set(&mut self, v: bool) {
        self.item_rarity_set = ::std::option::Option::Some(v);
    }

    // optional bool recent_only = 12;


    pub fn get_recent_only(&self) -> bool {
        self.recent_only.unwrap_or(false)
    }
    pub fn clear_recent_only(&mut self) {
        self.recent_only = ::std::option::Option::None;
    }

    pub fn has_recent_only(&self) -> bool {
        self.recent_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_only(&mut self, v: bool) {
        self.recent_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOItemCriteria {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.item_level_set = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.item_quality_set = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_inventory = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_quantity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_enabled_flag = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_rarity = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.item_rarity_set = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recent_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_level_set {
            my_size += 2;
        }
        if let Some(v) = self.item_quality_set {
            my_size += 2;
        }
        if let Some(v) = self.initial_inventory {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_quantity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ignore_enabled_flag {
            my_size += 2;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.item_rarity {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_rarity_set {
            my_size += 2;
        }
        if let Some(v) = self.recent_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level_set {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.item_quality_set {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.initial_inventory {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.initial_quantity {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ignore_enabled_flag {
            os.write_bool(8, v)?;
        }
        for v in &self.conditions {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.item_rarity {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.item_rarity_set {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.recent_only {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemCriteria {
        CSOItemCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_level",
                |m: &CSOItemCriteria| { &m.item_level },
                |m: &mut CSOItemCriteria| { &mut m.item_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "item_quality",
                |m: &CSOItemCriteria| { &m.item_quality },
                |m: &mut CSOItemCriteria| { &mut m.item_quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "item_level_set",
                |m: &CSOItemCriteria| { &m.item_level_set },
                |m: &mut CSOItemCriteria| { &mut m.item_level_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "item_quality_set",
                |m: &CSOItemCriteria| { &m.item_quality_set },
                |m: &mut CSOItemCriteria| { &mut m.item_quality_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_inventory",
                |m: &CSOItemCriteria| { &m.initial_inventory },
                |m: &mut CSOItemCriteria| { &mut m.initial_inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_quantity",
                |m: &CSOItemCriteria| { &m.initial_quantity },
                |m: &mut CSOItemCriteria| { &mut m.initial_quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ignore_enabled_flag",
                |m: &CSOItemCriteria| { &m.ignore_enabled_flag },
                |m: &mut CSOItemCriteria| { &mut m.ignore_enabled_flag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteriaCondition>>(
                "conditions",
                |m: &CSOItemCriteria| { &m.conditions },
                |m: &mut CSOItemCriteria| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "item_rarity",
                |m: &CSOItemCriteria| { &m.item_rarity },
                |m: &mut CSOItemCriteria| { &mut m.item_rarity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "item_rarity_set",
                |m: &CSOItemCriteria| { &m.item_rarity_set },
                |m: &mut CSOItemCriteria| { &mut m.item_rarity_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recent_only",
                |m: &CSOItemCriteria| { &m.recent_only },
                |m: &mut CSOItemCriteria| { &mut m.recent_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemCriteria>(
                "CSOItemCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemCriteria {
        static instance: ::protobuf::rt::LazyV2<CSOItemCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemCriteria::new)
    }
}

impl ::protobuf::Clear for CSOItemCriteria {
    fn clear(&mut self) {
        self.item_level = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_level_set = ::std::option::Option::None;
        self.item_quality_set = ::std::option::Option::None;
        self.initial_inventory = ::std::option::Option::None;
        self.initial_quantity = ::std::option::Option::None;
        self.ignore_enabled_flag = ::std::option::Option::None;
        self.conditions.clear();
        self.item_rarity = ::std::option::Option::None;
        self.item_rarity_set = ::std::option::Option::None;
        self.recent_only = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemRecipe {
    // message fields
    def_index: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    n_a: ::protobuf::SingularField<::std::string::String>,
    desc_inputs: ::protobuf::SingularField<::std::string::String>,
    desc_outputs: ::protobuf::SingularField<::std::string::String>,
    di_a: ::protobuf::SingularField<::std::string::String>,
    di_b: ::protobuf::SingularField<::std::string::String>,
    di_c: ::protobuf::SingularField<::std::string::String>,
    do_a: ::protobuf::SingularField<::std::string::String>,
    do_b: ::protobuf::SingularField<::std::string::String>,
    do_c: ::protobuf::SingularField<::std::string::String>,
    requires_all_same_class: ::std::option::Option<bool>,
    requires_all_same_slot: ::std::option::Option<bool>,
    class_usage_for_output: ::std::option::Option<i32>,
    slot_usage_for_output: ::std::option::Option<i32>,
    set_for_output: ::std::option::Option<i32>,
    pub input_items_criteria: ::protobuf::RepeatedField<CSOItemCriteria>,
    pub output_items_criteria: ::protobuf::RepeatedField<CSOItemCriteria>,
    pub input_item_dupe_counts: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemRecipe {
    fn default() -> &'a CSOItemRecipe {
        <CSOItemRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemRecipe {
    pub fn new() -> CSOItemRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string n_a = 3;


    pub fn get_n_a(&self) -> &str {
        match self.n_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_n_a(&mut self) {
        self.n_a.clear();
    }

    pub fn has_n_a(&self) -> bool {
        self.n_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_a(&mut self, v: ::std::string::String) {
        self.n_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n_a(&mut self) -> &mut ::std::string::String {
        if self.n_a.is_none() {
            self.n_a.set_default();
        }
        self.n_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_n_a(&mut self) -> ::std::string::String {
        self.n_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_inputs = 4;


    pub fn get_desc_inputs(&self) -> &str {
        match self.desc_inputs.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc_inputs(&mut self) {
        self.desc_inputs.clear();
    }

    pub fn has_desc_inputs(&self) -> bool {
        self.desc_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_inputs(&mut self, v: ::std::string::String) {
        self.desc_inputs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_inputs(&mut self) -> &mut ::std::string::String {
        if self.desc_inputs.is_none() {
            self.desc_inputs.set_default();
        }
        self.desc_inputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_inputs(&mut self) -> ::std::string::String {
        self.desc_inputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_outputs = 5;


    pub fn get_desc_outputs(&self) -> &str {
        match self.desc_outputs.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc_outputs(&mut self) {
        self.desc_outputs.clear();
    }

    pub fn has_desc_outputs(&self) -> bool {
        self.desc_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_outputs(&mut self, v: ::std::string::String) {
        self.desc_outputs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_outputs(&mut self) -> &mut ::std::string::String {
        if self.desc_outputs.is_none() {
            self.desc_outputs.set_default();
        }
        self.desc_outputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_outputs(&mut self) -> ::std::string::String {
        self.desc_outputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_a = 6;


    pub fn get_di_a(&self) -> &str {
        match self.di_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_a(&mut self) {
        self.di_a.clear();
    }

    pub fn has_di_a(&self) -> bool {
        self.di_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_a(&mut self, v: ::std::string::String) {
        self.di_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_a(&mut self) -> &mut ::std::string::String {
        if self.di_a.is_none() {
            self.di_a.set_default();
        }
        self.di_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_a(&mut self) -> ::std::string::String {
        self.di_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_b = 7;


    pub fn get_di_b(&self) -> &str {
        match self.di_b.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_b(&mut self) {
        self.di_b.clear();
    }

    pub fn has_di_b(&self) -> bool {
        self.di_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_b(&mut self, v: ::std::string::String) {
        self.di_b = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_b(&mut self) -> &mut ::std::string::String {
        if self.di_b.is_none() {
            self.di_b.set_default();
        }
        self.di_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_b(&mut self) -> ::std::string::String {
        self.di_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_c = 8;


    pub fn get_di_c(&self) -> &str {
        match self.di_c.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_c(&mut self) {
        self.di_c.clear();
    }

    pub fn has_di_c(&self) -> bool {
        self.di_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_c(&mut self, v: ::std::string::String) {
        self.di_c = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_c(&mut self) -> &mut ::std::string::String {
        if self.di_c.is_none() {
            self.di_c.set_default();
        }
        self.di_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_c(&mut self) -> ::std::string::String {
        self.di_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_a = 9;


    pub fn get_do_a(&self) -> &str {
        match self.do_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_a(&mut self) {
        self.do_a.clear();
    }

    pub fn has_do_a(&self) -> bool {
        self.do_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_a(&mut self, v: ::std::string::String) {
        self.do_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_a(&mut self) -> &mut ::std::string::String {
        if self.do_a.is_none() {
            self.do_a.set_default();
        }
        self.do_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_a(&mut self) -> ::std::string::String {
        self.do_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_b = 10;


    pub fn get_do_b(&self) -> &str {
        match self.do_b.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_b(&mut self) {
        self.do_b.clear();
    }

    pub fn has_do_b(&self) -> bool {
        self.do_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_b(&mut self, v: ::std::string::String) {
        self.do_b = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_b(&mut self) -> &mut ::std::string::String {
        if self.do_b.is_none() {
            self.do_b.set_default();
        }
        self.do_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_b(&mut self) -> ::std::string::String {
        self.do_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_c = 11;


    pub fn get_do_c(&self) -> &str {
        match self.do_c.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_c(&mut self) {
        self.do_c.clear();
    }

    pub fn has_do_c(&self) -> bool {
        self.do_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_c(&mut self, v: ::std::string::String) {
        self.do_c = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_c(&mut self) -> &mut ::std::string::String {
        if self.do_c.is_none() {
            self.do_c.set_default();
        }
        self.do_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_c(&mut self) -> ::std::string::String {
        self.do_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool requires_all_same_class = 12;


    pub fn get_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.unwrap_or(false)
    }
    pub fn clear_requires_all_same_class(&mut self) {
        self.requires_all_same_class = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_class(&mut self, v: bool) {
        self.requires_all_same_class = ::std::option::Option::Some(v);
    }

    // optional bool requires_all_same_slot = 13;


    pub fn get_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.unwrap_or(false)
    }
    pub fn clear_requires_all_same_slot(&mut self) {
        self.requires_all_same_slot = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_slot(&mut self, v: bool) {
        self.requires_all_same_slot = ::std::option::Option::Some(v);
    }

    // optional int32 class_usage_for_output = 14;


    pub fn get_class_usage_for_output(&self) -> i32 {
        self.class_usage_for_output.unwrap_or(0)
    }
    pub fn clear_class_usage_for_output(&mut self) {
        self.class_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_class_usage_for_output(&self) -> bool {
        self.class_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_usage_for_output(&mut self, v: i32) {
        self.class_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 slot_usage_for_output = 15;


    pub fn get_slot_usage_for_output(&self) -> i32 {
        self.slot_usage_for_output.unwrap_or(0)
    }
    pub fn clear_slot_usage_for_output(&mut self) {
        self.slot_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_slot_usage_for_output(&self) -> bool {
        self.slot_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_usage_for_output(&mut self, v: i32) {
        self.slot_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 set_for_output = 16;


    pub fn get_set_for_output(&self) -> i32 {
        self.set_for_output.unwrap_or(0)
    }
    pub fn clear_set_for_output(&mut self) {
        self.set_for_output = ::std::option::Option::None;
    }

    pub fn has_set_for_output(&self) -> bool {
        self.set_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_for_output(&mut self, v: i32) {
        self.set_for_output = ::std::option::Option::Some(v);
    }

    // repeated .CSOItemCriteria input_items_criteria = 20;


    pub fn get_input_items_criteria(&self) -> &[CSOItemCriteria] {
        &self.input_items_criteria
    }
    pub fn clear_input_items_criteria(&mut self) {
        self.input_items_criteria.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_items_criteria(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteria>) {
        self.input_items_criteria = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_items_criteria(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteria> {
        &mut self.input_items_criteria
    }

    // Take field
    pub fn take_input_items_criteria(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteria> {
        ::std::mem::replace(&mut self.input_items_criteria, ::protobuf::RepeatedField::new())
    }

    // repeated .CSOItemCriteria output_items_criteria = 21;


    pub fn get_output_items_criteria(&self) -> &[CSOItemCriteria] {
        &self.output_items_criteria
    }
    pub fn clear_output_items_criteria(&mut self) {
        self.output_items_criteria.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_items_criteria(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteria>) {
        self.output_items_criteria = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_items_criteria(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteria> {
        &mut self.output_items_criteria
    }

    // Take field
    pub fn take_output_items_criteria(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteria> {
        ::std::mem::replace(&mut self.output_items_criteria, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 input_item_dupe_counts = 22;


    pub fn get_input_item_dupe_counts(&self) -> &[u32] {
        &self.input_item_dupe_counts
    }
    pub fn clear_input_item_dupe_counts(&mut self) {
        self.input_item_dupe_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_item_dupe_counts(&mut self, v: ::std::vec::Vec<u32>) {
        self.input_item_dupe_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_item_dupe_counts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.input_item_dupe_counts
    }

    // Take field
    pub fn take_input_item_dupe_counts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.input_item_dupe_counts, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSOItemRecipe {
    fn is_initialized(&self) -> bool {
        for v in &self.input_items_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_items_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.n_a)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc_inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc_outputs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_a)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_b)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_c)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_a)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_b)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_c)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_all_same_class = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_all_same_slot = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.class_usage_for_output = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slot_usage_for_output = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.set_for_output = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input_items_criteria)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output_items_criteria)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.input_item_dupe_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.n_a.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.desc_inputs.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.desc_outputs.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.di_a.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.di_b.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.di_c.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.do_a.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.do_b.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.do_c.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.requires_all_same_class {
            my_size += 2;
        }
        if let Some(v) = self.requires_all_same_slot {
            my_size += 2;
        }
        if let Some(v) = self.class_usage_for_output {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_usage_for_output {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.set_for_output {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.input_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.output_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.input_item_dupe_counts {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.n_a.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.desc_inputs.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.desc_outputs.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.di_a.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.di_b.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.di_c.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.do_a.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.do_b.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.do_c.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.requires_all_same_class {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.requires_all_same_slot {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.class_usage_for_output {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.slot_usage_for_output {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.set_for_output {
            os.write_int32(16, v)?;
        }
        for v in &self.input_items_criteria {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.output_items_criteria {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.input_item_dupe_counts {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemRecipe {
        CSOItemRecipe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOItemRecipe| { &m.def_index },
                |m: &mut CSOItemRecipe| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CSOItemRecipe| { &m.name },
                |m: &mut CSOItemRecipe| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "n_a",
                |m: &CSOItemRecipe| { &m.n_a },
                |m: &mut CSOItemRecipe| { &mut m.n_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desc_inputs",
                |m: &CSOItemRecipe| { &m.desc_inputs },
                |m: &mut CSOItemRecipe| { &mut m.desc_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desc_outputs",
                |m: &CSOItemRecipe| { &m.desc_outputs },
                |m: &mut CSOItemRecipe| { &mut m.desc_outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_a",
                |m: &CSOItemRecipe| { &m.di_a },
                |m: &mut CSOItemRecipe| { &mut m.di_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_b",
                |m: &CSOItemRecipe| { &m.di_b },
                |m: &mut CSOItemRecipe| { &mut m.di_b },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_c",
                |m: &CSOItemRecipe| { &m.di_c },
                |m: &mut CSOItemRecipe| { &mut m.di_c },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_a",
                |m: &CSOItemRecipe| { &m.do_a },
                |m: &mut CSOItemRecipe| { &mut m.do_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_b",
                |m: &CSOItemRecipe| { &m.do_b },
                |m: &mut CSOItemRecipe| { &mut m.do_b },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_c",
                |m: &CSOItemRecipe| { &m.do_c },
                |m: &mut CSOItemRecipe| { &mut m.do_c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_all_same_class",
                |m: &CSOItemRecipe| { &m.requires_all_same_class },
                |m: &mut CSOItemRecipe| { &mut m.requires_all_same_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_all_same_slot",
                |m: &CSOItemRecipe| { &m.requires_all_same_slot },
                |m: &mut CSOItemRecipe| { &mut m.requires_all_same_slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "class_usage_for_output",
                |m: &CSOItemRecipe| { &m.class_usage_for_output },
                |m: &mut CSOItemRecipe| { &mut m.class_usage_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "slot_usage_for_output",
                |m: &CSOItemRecipe| { &m.slot_usage_for_output },
                |m: &mut CSOItemRecipe| { &mut m.slot_usage_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "set_for_output",
                |m: &CSOItemRecipe| { &m.set_for_output },
                |m: &mut CSOItemRecipe| { &mut m.set_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "input_items_criteria",
                |m: &CSOItemRecipe| { &m.input_items_criteria },
                |m: &mut CSOItemRecipe| { &mut m.input_items_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "output_items_criteria",
                |m: &CSOItemRecipe| { &m.output_items_criteria },
                |m: &mut CSOItemRecipe| { &mut m.output_items_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_item_dupe_counts",
                |m: &CSOItemRecipe| { &m.input_item_dupe_counts },
                |m: &mut CSOItemRecipe| { &mut m.input_item_dupe_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemRecipe>(
                "CSOItemRecipe",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemRecipe {
        static instance: ::protobuf::rt::LazyV2<CSOItemRecipe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemRecipe::new)
    }
}

impl ::protobuf::Clear for CSOItemRecipe {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name.clear();
        self.n_a.clear();
        self.desc_inputs.clear();
        self.desc_outputs.clear();
        self.di_a.clear();
        self.di_b.clear();
        self.di_c.clear();
        self.do_a.clear();
        self.do_b.clear();
        self.do_c.clear();
        self.requires_all_same_class = ::std::option::Option::None;
        self.requires_all_same_slot = ::std::option::Option::None;
        self.class_usage_for_output = ::std::option::Option::None;
        self.slot_usage_for_output = ::std::option::Option::None;
        self.set_for_output = ::std::option::Option::None;
        self.input_items_criteria.clear();
        self.output_items_criteria.clear();
        self.input_item_dupe_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemRecipe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDevNewItemRequest {
    // message fields
    receiver: ::std::option::Option<u64>,
    pub criteria: ::protobuf::SingularPtrField<CSOItemCriteria>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .CSOItemCriteria criteria = 2;


    pub fn get_criteria(&self) -> &CSOItemCriteria {
        self.criteria.as_ref().unwrap_or_else(|| <CSOItemCriteria as ::protobuf::Message>::default_instance())
    }
    pub fn clear_criteria(&mut self) {
        self.criteria.clear();
    }

    pub fn has_criteria(&self) -> bool {
        self.criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_criteria(&mut self, v: CSOItemCriteria) {
        self.criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_criteria(&mut self) -> &mut CSOItemCriteria {
        if self.criteria.is_none() {
            self.criteria.set_default();
        }
        self.criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_criteria(&mut self) -> CSOItemCriteria {
        self.criteria.take().unwrap_or_else(|| CSOItemCriteria::new())
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.criteria)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 9;
        }
        if let Some(ref v) = self.criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.criteria.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "receiver",
                |m: &CMsgDevNewItemRequest| { &m.receiver },
                |m: &mut CMsgDevNewItemRequest| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "criteria",
                |m: &CMsgDevNewItemRequest| { &m.criteria },
                |m: &mut CMsgDevNewItemRequest| { &mut m.criteria },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDevNewItemRequest>(
                "CMsgDevNewItemRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgDevNewItemRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDevNewItemRequest::new)
    }
}

impl ::protobuf::Clear for CMsgDevNewItemRequest {
    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.criteria.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgIncrementKillCountAttribute {
    // message fields
    killer_account_id: ::std::option::Option<u32>,
    victim_account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    event_type: ::std::option::Option<u32>,
    amount: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute {
    fn default() -> &'a CMsgIncrementKillCountAttribute {
        <CMsgIncrementKillCountAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute {
    pub fn new() -> CMsgIncrementKillCountAttribute {
        ::std::default::Default::default()
    }

    // optional fixed32 killer_account_id = 1;


    pub fn get_killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }
    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 victim_account_id = 2;


    pub fn get_victim_account_id(&self) -> u32 {
        self.victim_account_id.unwrap_or(0)
    }
    pub fn clear_victim_account_id(&mut self) {
        self.victim_account_id = ::std::option::Option::None;
    }

    pub fn has_victim_account_id(&self) -> bool {
        self.victim_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_account_id(&mut self, v: u32) {
        self.victim_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 5;


    pub fn get_amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.killer_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.victim_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += 5;
        }
        if let Some(v) = self.victim_account_id {
            my_size += 5;
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.victim_account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgIncrementKillCountAttribute {
        CMsgIncrementKillCountAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "killer_account_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.killer_account_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.killer_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "victim_account_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.victim_account_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.victim_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.item_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgIncrementKillCountAttribute| { &m.event_type },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "amount",
                |m: &CMsgIncrementKillCountAttribute| { &m.amount },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgIncrementKillCountAttribute>(
                "CMsgIncrementKillCountAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute {
        static instance: ::protobuf::rt::LazyV2<CMsgIncrementKillCountAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgIncrementKillCountAttribute::new)
    }
}

impl ::protobuf::Clear for CMsgIncrementKillCountAttribute {
    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.victim_account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgIncrementKillCountAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplySticker {
    // message fields
    sticker_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    sticker_slot: ::std::option::Option<u32>,
    baseitem_defidx: ::std::option::Option<u32>,
    sticker_wear: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplySticker {
    fn default() -> &'a CMsgApplySticker {
        <CMsgApplySticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplySticker {
    pub fn new() -> CMsgApplySticker {
        ::std::default::Default::default()
    }

    // optional uint64 sticker_item_id = 1;


    pub fn get_sticker_item_id(&self) -> u64 {
        self.sticker_item_id.unwrap_or(0)
    }
    pub fn clear_sticker_item_id(&mut self) {
        self.sticker_item_id = ::std::option::Option::None;
    }

    pub fn has_sticker_item_id(&self) -> bool {
        self.sticker_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_item_id(&mut self, v: u64) {
        self.sticker_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;


    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }
    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_slot = 3;


    pub fn get_sticker_slot(&self) -> u32 {
        self.sticker_slot.unwrap_or(0)
    }
    pub fn clear_sticker_slot(&mut self) {
        self.sticker_slot = ::std::option::Option::None;
    }

    pub fn has_sticker_slot(&self) -> bool {
        self.sticker_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_slot(&mut self, v: u32) {
        self.sticker_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 baseitem_defidx = 4;


    pub fn get_baseitem_defidx(&self) -> u32 {
        self.baseitem_defidx.unwrap_or(0)
    }
    pub fn clear_baseitem_defidx(&mut self) {
        self.baseitem_defidx = ::std::option::Option::None;
    }

    pub fn has_baseitem_defidx(&self) -> bool {
        self.baseitem_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseitem_defidx(&mut self, v: u32) {
        self.baseitem_defidx = ::std::option::Option::Some(v);
    }

    // optional float sticker_wear = 5;


    pub fn get_sticker_wear(&self) -> f32 {
        self.sticker_wear.unwrap_or(0.)
    }
    pub fn clear_sticker_wear(&mut self) {
        self.sticker_wear = ::std::option::Option::None;
    }

    pub fn has_sticker_wear(&self) -> bool {
        self.sticker_wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_wear(&mut self, v: f32) {
        self.sticker_wear = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplySticker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sticker_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sticker_slot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.baseitem_defidx = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.sticker_wear = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sticker_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sticker_slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.baseitem_defidx {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sticker_wear {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sticker_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.sticker_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.baseitem_defidx {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sticker_wear {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplySticker {
        CMsgApplySticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sticker_item_id",
                |m: &CMsgApplySticker| { &m.sticker_item_id },
                |m: &mut CMsgApplySticker| { &mut m.sticker_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_item_id",
                |m: &CMsgApplySticker| { &m.item_item_id },
                |m: &mut CMsgApplySticker| { &mut m.item_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sticker_slot",
                |m: &CMsgApplySticker| { &m.sticker_slot },
                |m: &mut CMsgApplySticker| { &mut m.sticker_slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "baseitem_defidx",
                |m: &CMsgApplySticker| { &m.baseitem_defidx },
                |m: &mut CMsgApplySticker| { &mut m.baseitem_defidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "sticker_wear",
                |m: &CMsgApplySticker| { &m.sticker_wear },
                |m: &mut CMsgApplySticker| { &mut m.sticker_wear },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplySticker>(
                "CMsgApplySticker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplySticker {
        static instance: ::protobuf::rt::LazyV2<CMsgApplySticker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplySticker::new)
    }
}

impl ::protobuf::Clear for CMsgApplySticker {
    fn clear(&mut self) {
        self.sticker_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.sticker_slot = ::std::option::Option::None;
        self.baseitem_defidx = ::std::option::Option::None;
        self.sticker_wear = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplySticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplySticker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgModifyItemAttribute {
    // message fields
    item_id: ::std::option::Option<u64>,
    attr_defidx: ::std::option::Option<u32>,
    attr_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgModifyItemAttribute {
    fn default() -> &'a CMsgModifyItemAttribute {
        <CMsgModifyItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgModifyItemAttribute {
    pub fn new() -> CMsgModifyItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_defidx = 2;


    pub fn get_attr_defidx(&self) -> u32 {
        self.attr_defidx.unwrap_or(0)
    }
    pub fn clear_attr_defidx(&mut self) {
        self.attr_defidx = ::std::option::Option::None;
    }

    pub fn has_attr_defidx(&self) -> bool {
        self.attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_defidx(&mut self, v: u32) {
        self.attr_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_value = 3;


    pub fn get_attr_value(&self) -> u32 {
        self.attr_value.unwrap_or(0)
    }
    pub fn clear_attr_value(&mut self) {
        self.attr_value = ::std::option::Option::None;
    }

    pub fn has_attr_value(&self) -> bool {
        self.attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_value(&mut self, v: u32) {
        self.attr_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgModifyItemAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attr_defidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attr_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attr_defidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attr_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.attr_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgModifyItemAttribute {
        CMsgModifyItemAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgModifyItemAttribute| { &m.item_id },
                |m: &mut CMsgModifyItemAttribute| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attr_defidx",
                |m: &CMsgModifyItemAttribute| { &m.attr_defidx },
                |m: &mut CMsgModifyItemAttribute| { &mut m.attr_defidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attr_value",
                |m: &CMsgModifyItemAttribute| { &m.attr_value },
                |m: &mut CMsgModifyItemAttribute| { &mut m.attr_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgModifyItemAttribute>(
                "CMsgModifyItemAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgModifyItemAttribute {
        static instance: ::protobuf::rt::LazyV2<CMsgModifyItemAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgModifyItemAttribute::new)
    }
}

impl ::protobuf::Clear for CMsgModifyItemAttribute {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attr_defidx = ::std::option::Option::None;
        self.attr_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgModifyItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgModifyItemAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyStatTrakSwap {
    // message fields
    tool_item_id: ::std::option::Option<u64>,
    item_1_item_id: ::std::option::Option<u64>,
    item_2_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStatTrakSwap {
    fn default() -> &'a CMsgApplyStatTrakSwap {
        <CMsgApplyStatTrakSwap as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStatTrakSwap {
    pub fn new() -> CMsgApplyStatTrakSwap {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;


    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }
    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_1_item_id = 2;


    pub fn get_item_1_item_id(&self) -> u64 {
        self.item_1_item_id.unwrap_or(0)
    }
    pub fn clear_item_1_item_id(&mut self) {
        self.item_1_item_id = ::std::option::Option::None;
    }

    pub fn has_item_1_item_id(&self) -> bool {
        self.item_1_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_1_item_id(&mut self, v: u64) {
        self.item_1_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_2_item_id = 3;


    pub fn get_item_2_item_id(&self) -> u64 {
        self.item_2_item_id.unwrap_or(0)
    }
    pub fn clear_item_2_item_id(&mut self) {
        self.item_2_item_id = ::std::option::Option::None;
    }

    pub fn has_item_2_item_id(&self) -> bool {
        self.item_2_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_2_item_id(&mut self, v: u64) {
        self.item_2_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyStatTrakSwap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_1_item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_2_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_1_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_2_item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_1_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_2_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyStatTrakSwap {
        CMsgApplyStatTrakSwap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_item_id",
                |m: &CMsgApplyStatTrakSwap| { &m.tool_item_id },
                |m: &mut CMsgApplyStatTrakSwap| { &mut m.tool_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_1_item_id",
                |m: &CMsgApplyStatTrakSwap| { &m.item_1_item_id },
                |m: &mut CMsgApplyStatTrakSwap| { &mut m.item_1_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_2_item_id",
                |m: &CMsgApplyStatTrakSwap| { &m.item_2_item_id },
                |m: &mut CMsgApplyStatTrakSwap| { &mut m.item_2_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyStatTrakSwap>(
                "CMsgApplyStatTrakSwap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyStatTrakSwap {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyStatTrakSwap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyStatTrakSwap::new)
    }
}

impl ::protobuf::Clear for CMsgApplyStatTrakSwap {
    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_1_item_id = ::std::option::Option::None;
        self.item_2_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyStatTrakSwap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStatTrakSwap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyStrangePart {
    // message fields
    strange_part_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;


    pub fn get_strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }
    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;


    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }
    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyStrangePart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.strange_part_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "strange_part_item_id",
                |m: &CMsgApplyStrangePart| { &m.strange_part_item_id },
                |m: &mut CMsgApplyStrangePart| { &mut m.strange_part_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_item_id",
                |m: &CMsgApplyStrangePart| { &m.item_item_id },
                |m: &mut CMsgApplyStrangePart| { &mut m.item_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyStrangePart>(
                "CMsgApplyStrangePart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyStrangePart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyStrangePart::new)
    }
}

impl ::protobuf::Clear for CMsgApplyStrangePart {
    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangePart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyPennantUpgrade {
    // message fields
    upgrade_item_id: ::std::option::Option<u64>,
    pennant_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyPennantUpgrade {
    fn default() -> &'a CMsgApplyPennantUpgrade {
        <CMsgApplyPennantUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyPennantUpgrade {
    pub fn new() -> CMsgApplyPennantUpgrade {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_item_id = 1;


    pub fn get_upgrade_item_id(&self) -> u64 {
        self.upgrade_item_id.unwrap_or(0)
    }
    pub fn clear_upgrade_item_id(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_item_id(&self) -> bool {
        self.upgrade_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_item_id(&mut self, v: u64) {
        self.upgrade_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 pennant_item_id = 2;


    pub fn get_pennant_item_id(&self) -> u64 {
        self.pennant_item_id.unwrap_or(0)
    }
    pub fn clear_pennant_item_id(&mut self) {
        self.pennant_item_id = ::std::option::Option::None;
    }

    pub fn has_pennant_item_id(&self) -> bool {
        self.pennant_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pennant_item_id(&mut self, v: u64) {
        self.pennant_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyPennantUpgrade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upgrade_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pennant_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pennant_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upgrade_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pennant_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyPennantUpgrade {
        CMsgApplyPennantUpgrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upgrade_item_id",
                |m: &CMsgApplyPennantUpgrade| { &m.upgrade_item_id },
                |m: &mut CMsgApplyPennantUpgrade| { &mut m.upgrade_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pennant_item_id",
                |m: &CMsgApplyPennantUpgrade| { &m.pennant_item_id },
                |m: &mut CMsgApplyPennantUpgrade| { &mut m.pennant_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyPennantUpgrade>(
                "CMsgApplyPennantUpgrade",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyPennantUpgrade {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyPennantUpgrade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyPennantUpgrade::new)
    }
}

impl ::protobuf::Clear for CMsgApplyPennantUpgrade {
    fn clear(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
        self.pennant_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyPennantUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyPennantUpgrade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyEggEssence {
    // message fields
    essence_item_id: ::std::option::Option<u64>,
    egg_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyEggEssence {
    fn default() -> &'a CMsgApplyEggEssence {
        <CMsgApplyEggEssence as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyEggEssence {
    pub fn new() -> CMsgApplyEggEssence {
        ::std::default::Default::default()
    }

    // optional uint64 essence_item_id = 1;


    pub fn get_essence_item_id(&self) -> u64 {
        self.essence_item_id.unwrap_or(0)
    }
    pub fn clear_essence_item_id(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
    }

    pub fn has_essence_item_id(&self) -> bool {
        self.essence_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essence_item_id(&mut self, v: u64) {
        self.essence_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 egg_item_id = 2;


    pub fn get_egg_item_id(&self) -> u64 {
        self.egg_item_id.unwrap_or(0)
    }
    pub fn clear_egg_item_id(&mut self) {
        self.egg_item_id = ::std::option::Option::None;
    }

    pub fn has_egg_item_id(&self) -> bool {
        self.egg_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egg_item_id(&mut self, v: u64) {
        self.egg_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyEggEssence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.essence_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.egg_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.essence_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.egg_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.essence_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.egg_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyEggEssence {
        CMsgApplyEggEssence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "essence_item_id",
                |m: &CMsgApplyEggEssence| { &m.essence_item_id },
                |m: &mut CMsgApplyEggEssence| { &mut m.essence_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "egg_item_id",
                |m: &CMsgApplyEggEssence| { &m.egg_item_id },
                |m: &mut CMsgApplyEggEssence| { &mut m.egg_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyEggEssence>(
                "CMsgApplyEggEssence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyEggEssence {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyEggEssence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyEggEssence::new)
    }
}

impl ::protobuf::Clear for CMsgApplyEggEssence {
    fn clear(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
        self.egg_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyEggEssence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyEggEssence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemAttribute {
    // message fields
    def_index: ::std::option::Option<u32>,
    value: ::std::option::Option<u32>,
    value_bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;


    pub fn get_value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value_bytes(&mut self) {
        self.value_bytes.clear();
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes.set_default();
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSOEconItemAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.value_bytes.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOEconItemAttribute| { &m.def_index },
                |m: &mut CSOEconItemAttribute| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &CSOEconItemAttribute| { &m.value },
                |m: &mut CSOEconItemAttribute| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_bytes",
                |m: &CSOEconItemAttribute| { &m.value_bytes },
                |m: &mut CSOEconItemAttribute| { &mut m.value_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemAttribute>(
                "CSOEconItemAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemAttribute::new)
    }
}

impl ::protobuf::Clear for CSOEconItemAttribute {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemEquipped {
    // message fields
    new_class: ::std::option::Option<u32>,
    new_slot: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;


    pub fn get_new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }
    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;


    pub fn get_new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }
    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemEquipped {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_class = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_slot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_class",
                |m: &CSOEconItemEquipped| { &m.new_class },
                |m: &mut CSOEconItemEquipped| { &mut m.new_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_slot",
                |m: &CSOEconItemEquipped| { &m.new_slot },
                |m: &mut CSOEconItemEquipped| { &mut m.new_slot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemEquipped>(
                "CSOEconItemEquipped",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemEquipped> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemEquipped::new)
    }
}

impl ::protobuf::Clear for CSOEconItemEquipped {
    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemEquipped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEquipped {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItem {
    // message fields
    id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    inventory: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    custom_name: ::protobuf::SingularField<::std::string::String>,
    custom_desc: ::protobuf::SingularField<::std::string::String>,
    pub attribute: ::protobuf::RepeatedField<CSOEconItemAttribute>,
    pub interior_item: ::protobuf::SingularPtrField<CSOEconItem>,
    in_use: ::std::option::Option<bool>,
    style: ::std::option::Option<u32>,
    original_id: ::std::option::Option<u64>,
    pub equipped_state: ::protobuf::RepeatedField<CSOEconItemEquipped>,
    rarity: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;


    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }
    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;


    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;


    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;


    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;


    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }
    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional string custom_name = 10;


    pub fn get_custom_name(&self) -> &str {
        match self.custom_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_name(&mut self) {
        self.custom_name.clear();
    }

    pub fn has_custom_name(&self) -> bool {
        self.custom_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_name(&mut self, v: ::std::string::String) {
        self.custom_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_name(&mut self) -> &mut ::std::string::String {
        if self.custom_name.is_none() {
            self.custom_name.set_default();
        }
        self.custom_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_name(&mut self) -> ::std::string::String {
        self.custom_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_desc = 11;


    pub fn get_custom_desc(&self) -> &str {
        match self.custom_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_desc(&mut self) {
        self.custom_desc.clear();
    }

    pub fn has_custom_desc(&self) -> bool {
        self.custom_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_desc(&mut self, v: ::std::string::String) {
        self.custom_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_desc(&mut self) -> &mut ::std::string::String {
        if self.custom_desc.is_none() {
            self.custom_desc.set_default();
        }
        self.custom_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_desc(&mut self) -> ::std::string::String {
        self.custom_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CSOEconItemAttribute attribute = 12;


    pub fn get_attribute(&self) -> &[CSOEconItemAttribute] {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<CSOEconItemAttribute>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<CSOEconItemAttribute> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<CSOEconItemAttribute> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    // optional .CSOEconItem interior_item = 13;


    pub fn get_interior_item(&self) -> &CSOEconItem {
        self.interior_item.as_ref().unwrap_or_else(|| <CSOEconItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interior_item(&mut self) {
        self.interior_item.clear();
    }

    pub fn has_interior_item(&self) -> bool {
        self.interior_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interior_item(&mut self, v: CSOEconItem) {
        self.interior_item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interior_item(&mut self) -> &mut CSOEconItem {
        if self.interior_item.is_none() {
            self.interior_item.set_default();
        }
        self.interior_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_interior_item(&mut self) -> CSOEconItem {
        self.interior_item.take().unwrap_or_else(|| CSOEconItem::new())
    }

    // optional bool in_use = 14;


    pub fn get_in_use(&self) -> bool {
        self.in_use.unwrap_or(false)
    }
    pub fn clear_in_use(&mut self) {
        self.in_use = ::std::option::Option::None;
    }

    pub fn has_in_use(&self) -> bool {
        self.in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_use(&mut self, v: bool) {
        self.in_use = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;


    pub fn get_style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }
    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;


    pub fn get_original_id(&self) -> u64 {
        self.original_id.unwrap_or(0u64)
    }
    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // repeated .CSOEconItemEquipped equipped_state = 18;


    pub fn get_equipped_state(&self) -> &[CSOEconItemEquipped] {
        &self.equipped_state
    }
    pub fn clear_equipped_state(&mut self) {
        self.equipped_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_equipped_state(&mut self, v: ::protobuf::RepeatedField<CSOEconItemEquipped>) {
        self.equipped_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equipped_state(&mut self) -> &mut ::protobuf::RepeatedField<CSOEconItemEquipped> {
        &mut self.equipped_state
    }

    // Take field
    pub fn take_equipped_state(&mut self) -> ::protobuf::RepeatedField<CSOEconItemEquipped> {
        ::std::mem::replace(&mut self.equipped_state, ::protobuf::RepeatedField::new())
    }

    // optional uint32 rarity = 19;


    pub fn get_rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }
    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItem {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interior_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.equipped_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_name)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_desc)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interior_item)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_use = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_id = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equipped_state)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.custom_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.in_use {
            my_size += 2;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.original_id {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.custom_name.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.custom_desc.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.attribute {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.interior_item.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.in_use {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        for v in &self.equipped_state {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.rarity {
            os.write_uint32(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CSOEconItem| { &m.id },
                |m: &mut CSOEconItem| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconItem| { &m.account_id },
                |m: &mut CSOEconItem| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inventory",
                |m: &CSOEconItem| { &m.inventory },
                |m: &mut CSOEconItem| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOEconItem| { &m.def_index },
                |m: &mut CSOEconItem| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quantity",
                |m: &CSOEconItem| { &m.quantity },
                |m: &mut CSOEconItem| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level",
                |m: &CSOEconItem| { &m.level },
                |m: &mut CSOEconItem| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality",
                |m: &CSOEconItem| { &m.quality },
                |m: &mut CSOEconItem| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CSOEconItem| { &m.flags },
                |m: &mut CSOEconItem| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin",
                |m: &CSOEconItem| { &m.origin },
                |m: &mut CSOEconItem| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_name",
                |m: &CSOEconItem| { &m.custom_name },
                |m: &mut CSOEconItem| { &mut m.custom_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_desc",
                |m: &CSOEconItem| { &m.custom_desc },
                |m: &mut CSOEconItem| { &mut m.custom_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItemAttribute>>(
                "attribute",
                |m: &CSOEconItem| { &m.attribute },
                |m: &mut CSOEconItem| { &mut m.attribute },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItem>>(
                "interior_item",
                |m: &CSOEconItem| { &m.interior_item },
                |m: &mut CSOEconItem| { &mut m.interior_item },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_use",
                |m: &CSOEconItem| { &m.in_use },
                |m: &mut CSOEconItem| { &mut m.in_use },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "style",
                |m: &CSOEconItem| { &m.style },
                |m: &mut CSOEconItem| { &mut m.style },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_id",
                |m: &CSOEconItem| { &m.original_id },
                |m: &mut CSOEconItem| { &mut m.original_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItemEquipped>>(
                "equipped_state",
                |m: &CSOEconItem| { &m.equipped_state },
                |m: &mut CSOEconItem| { &mut m.equipped_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rarity",
                |m: &CSOEconItem| { &m.rarity },
                |m: &mut CSOEconItem| { &mut m.rarity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItem>(
                "CSOEconItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: ::protobuf::rt::LazyV2<CSOEconItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItem::new)
    }
}

impl ::protobuf::Clear for CSOEconItem {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.custom_name.clear();
        self.custom_desc.clear();
        self.attribute.clear();
        self.interior_item.clear();
        self.in_use = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.equipped_state.clear();
        self.rarity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    item_id: ::std::option::Option<u64>,
    new_class: ::std::option::Option<u32>,
    new_slot: ::std::option::Option<u32>,
    swap: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;


    pub fn get_new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }
    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;


    pub fn get_new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }
    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    // optional bool swap = 4;


    pub fn get_swap(&self) -> bool {
        self.swap.unwrap_or(false)
    }
    pub fn clear_swap(&mut self) {
        self.swap = ::std::option::Option::None;
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: bool) {
        self.swap = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_class = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_slot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.swap = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.swap {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.swap {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgAdjustItemEquippedState| { &m.item_id },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_class",
                |m: &CMsgAdjustItemEquippedState| { &m.new_class },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_slot",
                |m: &CMsgAdjustItemEquippedState| { &m.new_slot },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "swap",
                |m: &CMsgAdjustItemEquippedState| { &m.swap },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.swap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAdjustItemEquippedState>(
                "CMsgAdjustItemEquippedState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: ::protobuf::rt::LazyV2<CMsgAdjustItemEquippedState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAdjustItemEquippedState::new)
    }
}

impl ::protobuf::Clear for CMsgAdjustItemEquippedState {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.swap = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAdjustItemEquippedStateMulti {
    // message fields
    pub t_equips: ::std::vec::Vec<u64>,
    pub ct_equips: ::std::vec::Vec<u64>,
    pub noteam_equips: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedStateMulti {
    fn default() -> &'a CMsgAdjustItemEquippedStateMulti {
        <CMsgAdjustItemEquippedStateMulti as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedStateMulti {
    pub fn new() -> CMsgAdjustItemEquippedStateMulti {
        ::std::default::Default::default()
    }

    // repeated uint64 t_equips = 1;


    pub fn get_t_equips(&self) -> &[u64] {
        &self.t_equips
    }
    pub fn clear_t_equips(&mut self) {
        self.t_equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_t_equips(&mut self, v: ::std::vec::Vec<u64>) {
        self.t_equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_t_equips(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.t_equips
    }

    // Take field
    pub fn take_t_equips(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.t_equips, ::std::vec::Vec::new())
    }

    // repeated uint64 ct_equips = 2;


    pub fn get_ct_equips(&self) -> &[u64] {
        &self.ct_equips
    }
    pub fn clear_ct_equips(&mut self) {
        self.ct_equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_ct_equips(&mut self, v: ::std::vec::Vec<u64>) {
        self.ct_equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ct_equips(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.ct_equips
    }

    // Take field
    pub fn take_ct_equips(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.ct_equips, ::std::vec::Vec::new())
    }

    // repeated uint64 noteam_equips = 3;


    pub fn get_noteam_equips(&self) -> &[u64] {
        &self.noteam_equips
    }
    pub fn clear_noteam_equips(&mut self) {
        self.noteam_equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteam_equips(&mut self, v: ::std::vec::Vec<u64>) {
        self.noteam_equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_noteam_equips(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.noteam_equips
    }

    // Take field
    pub fn take_noteam_equips(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.noteam_equips, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedStateMulti {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.t_equips)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.ct_equips)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.noteam_equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.t_equips {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.ct_equips {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.noteam_equips {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.t_equips {
            os.write_uint64(1, *v)?;
        };
        for v in &self.ct_equips {
            os.write_uint64(2, *v)?;
        };
        for v in &self.noteam_equips {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAdjustItemEquippedStateMulti {
        CMsgAdjustItemEquippedStateMulti::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "t_equips",
                |m: &CMsgAdjustItemEquippedStateMulti| { &m.t_equips },
                |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.t_equips },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ct_equips",
                |m: &CMsgAdjustItemEquippedStateMulti| { &m.ct_equips },
                |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.ct_equips },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "noteam_equips",
                |m: &CMsgAdjustItemEquippedStateMulti| { &m.noteam_equips },
                |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.noteam_equips },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAdjustItemEquippedStateMulti>(
                "CMsgAdjustItemEquippedStateMulti",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedStateMulti {
        static instance: ::protobuf::rt::LazyV2<CMsgAdjustItemEquippedStateMulti> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAdjustItemEquippedStateMulti::new)
    }
}

impl ::protobuf::Clear for CMsgAdjustItemEquippedStateMulti {
    fn clear(&mut self) {
        self.t_equips.clear();
        self.ct_equips.clear();
        self.noteam_equips.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAdjustItemEquippedStateMulti {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedStateMulti {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSortItems {
    // message fields
    sort_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;


    pub fn get_sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }
    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSortItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sort_type",
                |m: &CMsgSortItems| { &m.sort_type },
                |m: &mut CMsgSortItems| { &mut m.sort_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSortItems>(
                "CMsgSortItems",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: ::protobuf::rt::LazyV2<CMsgSortItems> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSortItems::new)
    }
}

impl ::protobuf::Clear for CMsgSortItems {
    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSortItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSortItems {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconClaimCode {
    // message fields
    account_id: ::std::option::Option<u32>,
    code_type: ::std::option::Option<u32>,
    time_acquired: ::std::option::Option<u32>,
    code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconClaimCode {
    fn default() -> &'a CSOEconClaimCode {
        <CSOEconClaimCode as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconClaimCode {
    pub fn new() -> CSOEconClaimCode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 code_type = 2;


    pub fn get_code_type(&self) -> u32 {
        self.code_type.unwrap_or(0)
    }
    pub fn clear_code_type(&mut self) {
        self.code_type = ::std::option::Option::None;
    }

    pub fn has_code_type(&self) -> bool {
        self.code_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_type(&mut self, v: u32) {
        self.code_type = ::std::option::Option::Some(v);
    }

    // optional uint32 time_acquired = 3;


    pub fn get_time_acquired(&self) -> u32 {
        self.time_acquired.unwrap_or(0)
    }
    pub fn clear_time_acquired(&mut self) {
        self.time_acquired = ::std::option::Option::None;
    }

    pub fn has_time_acquired(&self) -> bool {
        self.time_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_acquired(&mut self, v: u32) {
        self.time_acquired = ::std::option::Option::Some(v);
    }

    // optional string code = 4;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOEconClaimCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_acquired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.code_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_acquired {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_acquired {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconClaimCode {
        CSOEconClaimCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconClaimCode| { &m.account_id },
                |m: &mut CSOEconClaimCode| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "code_type",
                |m: &CSOEconClaimCode| { &m.code_type },
                |m: &mut CSOEconClaimCode| { &mut m.code_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_acquired",
                |m: &CSOEconClaimCode| { &m.time_acquired },
                |m: &mut CSOEconClaimCode| { &mut m.time_acquired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &CSOEconClaimCode| { &m.code },
                |m: &mut CSOEconClaimCode| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconClaimCode>(
                "CSOEconClaimCode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconClaimCode {
        static instance: ::protobuf::rt::LazyV2<CSOEconClaimCode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconClaimCode::new)
    }
}

impl ::protobuf::Clear for CSOEconClaimCode {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.code_type = ::std::option::Option::None;
        self.time_acquired = ::std::option::Option::None;
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconClaimCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconClaimCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgStoreGetUserData {
    // message fields
    price_sheet_version: ::std::option::Option<u32>,
    currency: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserData {
    fn default() -> &'a CMsgStoreGetUserData {
        <CMsgStoreGetUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserData {
    pub fn new() -> CMsgStoreGetUserData {
        ::std::default::Default::default()
    }

    // optional fixed32 price_sheet_version = 1;


    pub fn get_price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }
    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 2;


    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStoreGetUserData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.price_sheet_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.price_sheet_version {
            my_size += 5;
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStoreGetUserData {
        CMsgStoreGetUserData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "price_sheet_version",
                |m: &CMsgStoreGetUserData| { &m.price_sheet_version },
                |m: &mut CMsgStoreGetUserData| { &mut m.price_sheet_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency",
                |m: &CMsgStoreGetUserData| { &m.currency },
                |m: &mut CMsgStoreGetUserData| { &mut m.currency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgStoreGetUserData>(
                "CMsgStoreGetUserData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgStoreGetUserData {
        static instance: ::protobuf::rt::LazyV2<CMsgStoreGetUserData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgStoreGetUserData::new)
    }
}

impl ::protobuf::Clear for CMsgStoreGetUserData {
    fn clear(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStoreGetUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgStoreGetUserDataResponse {
    // message fields
    result: ::std::option::Option<i32>,
    currency_deprecated: ::std::option::Option<i32>,
    country_deprecated: ::protobuf::SingularField<::std::string::String>,
    price_sheet_version: ::std::option::Option<u32>,
    price_sheet: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserDataResponse {
    fn default() -> &'a CMsgStoreGetUserDataResponse {
        <CMsgStoreGetUserDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserDataResponse {
    pub fn new() -> CMsgStoreGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 currency_deprecated = 2;


    pub fn get_currency_deprecated(&self) -> i32 {
        self.currency_deprecated.unwrap_or(0)
    }
    pub fn clear_currency_deprecated(&mut self) {
        self.currency_deprecated = ::std::option::Option::None;
    }

    pub fn has_currency_deprecated(&self) -> bool {
        self.currency_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_deprecated(&mut self, v: i32) {
        self.currency_deprecated = ::std::option::Option::Some(v);
    }

    // optional string country_deprecated = 3;


    pub fn get_country_deprecated(&self) -> &str {
        match self.country_deprecated.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_deprecated(&mut self) {
        self.country_deprecated.clear();
    }

    pub fn has_country_deprecated(&self) -> bool {
        self.country_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_deprecated(&mut self, v: ::std::string::String) {
        self.country_deprecated = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_deprecated(&mut self) -> &mut ::std::string::String {
        if self.country_deprecated.is_none() {
            self.country_deprecated.set_default();
        }
        self.country_deprecated.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_deprecated(&mut self) -> ::std::string::String {
        self.country_deprecated.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 price_sheet_version = 4;


    pub fn get_price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }
    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional bytes price_sheet = 8;


    pub fn get_price_sheet(&self) -> &[u8] {
        match self.price_sheet.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_price_sheet(&mut self) {
        self.price_sheet.clear();
    }

    pub fn has_price_sheet(&self) -> bool {
        self.price_sheet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet(&mut self, v: ::std::vec::Vec<u8>) {
        self.price_sheet = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_sheet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.price_sheet.is_none() {
            self.price_sheet.set_default();
        }
        self.price_sheet.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_sheet(&mut self) -> ::std::vec::Vec<u8> {
        self.price_sheet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgStoreGetUserDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency_deprecated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_deprecated)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.price_sheet_version = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.price_sheet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency_deprecated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.country_deprecated.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.price_sheet_version {
            my_size += 5;
        }
        if let Some(ref v) = self.price_sheet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currency_deprecated {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.country_deprecated.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(4, v)?;
        }
        if let Some(ref v) = self.price_sheet.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStoreGetUserDataResponse {
        CMsgStoreGetUserDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CMsgStoreGetUserDataResponse| { &m.result },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency_deprecated",
                |m: &CMsgStoreGetUserDataResponse| { &m.currency_deprecated },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.currency_deprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_deprecated",
                |m: &CMsgStoreGetUserDataResponse| { &m.country_deprecated },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.country_deprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "price_sheet_version",
                |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet_version },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "price_sheet",
                |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgStoreGetUserDataResponse>(
                "CMsgStoreGetUserDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgStoreGetUserDataResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgStoreGetUserDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgStoreGetUserDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgStoreGetUserDataResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.currency_deprecated = ::std::option::Option::None;
        self.country_deprecated.clear();
        self.price_sheet_version = ::std::option::Option::None;
        self.price_sheet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStoreGetUserDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpdateItemSchema {
    // message fields
    items_game: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    item_schema_version: ::std::option::Option<u32>,
    items_game_url_DEPRECATED2013: ::protobuf::SingularField<::std::string::String>,
    items_game_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateItemSchema {
    fn default() -> &'a CMsgUpdateItemSchema {
        <CMsgUpdateItemSchema as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateItemSchema {
    pub fn new() -> CMsgUpdateItemSchema {
        ::std::default::Default::default()
    }

    // optional bytes items_game = 1;


    pub fn get_items_game(&self) -> &[u8] {
        match self.items_game.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_items_game(&mut self) {
        self.items_game.clear();
    }

    pub fn has_items_game(&self) -> bool {
        self.items_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game(&mut self, v: ::std::vec::Vec<u8>) {
        self.items_game = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.items_game.is_none() {
            self.items_game.set_default();
        }
        self.items_game.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game(&mut self) -> ::std::vec::Vec<u8> {
        self.items_game.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 item_schema_version = 2;


    pub fn get_item_schema_version(&self) -> u32 {
        self.item_schema_version.unwrap_or(0)
    }
    pub fn clear_item_schema_version(&mut self) {
        self.item_schema_version = ::std::option::Option::None;
    }

    pub fn has_item_schema_version(&self) -> bool {
        self.item_schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_schema_version(&mut self, v: u32) {
        self.item_schema_version = ::std::option::Option::Some(v);
    }

    // optional string items_game_url_DEPRECATED2013 = 3;


    pub fn get_items_game_url_DEPRECATED2013(&self) -> &str {
        match self.items_game_url_DEPRECATED2013.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_items_game_url_DEPRECATED2013(&mut self) {
        self.items_game_url_DEPRECATED2013.clear();
    }

    pub fn has_items_game_url_DEPRECATED2013(&self) -> bool {
        self.items_game_url_DEPRECATED2013.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url_DEPRECATED2013(&mut self, v: ::std::string::String) {
        self.items_game_url_DEPRECATED2013 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url_DEPRECATED2013(&mut self) -> &mut ::std::string::String {
        if self.items_game_url_DEPRECATED2013.is_none() {
            self.items_game_url_DEPRECATED2013.set_default();
        }
        self.items_game_url_DEPRECATED2013.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url_DEPRECATED2013(&mut self) -> ::std::string::String {
        self.items_game_url_DEPRECATED2013.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string items_game_url = 4;


    pub fn get_items_game_url(&self) -> &str {
        match self.items_game_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_items_game_url(&mut self) {
        self.items_game_url.clear();
    }

    pub fn has_items_game_url(&self) -> bool {
        self.items_game_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url(&mut self, v: ::std::string::String) {
        self.items_game_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url(&mut self) -> &mut ::std::string::String {
        if self.items_game_url.is_none() {
            self.items_game_url.set_default();
        }
        self.items_game_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url(&mut self) -> ::std::string::String {
        self.items_game_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgUpdateItemSchema {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.items_game)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.item_schema_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.items_game_url_DEPRECATED2013)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.items_game_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.items_game.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_schema_version {
            my_size += 5;
        }
        if let Some(ref v) = self.items_game_url_DEPRECATED2013.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.items_game_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.items_game.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.item_schema_version {
            os.write_fixed32(2, v)?;
        }
        if let Some(ref v) = self.items_game_url_DEPRECATED2013.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.items_game_url.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdateItemSchema {
        CMsgUpdateItemSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "items_game",
                |m: &CMsgUpdateItemSchema| { &m.items_game },
                |m: &mut CMsgUpdateItemSchema| { &mut m.items_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "item_schema_version",
                |m: &CMsgUpdateItemSchema| { &m.item_schema_version },
                |m: &mut CMsgUpdateItemSchema| { &mut m.item_schema_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "items_game_url_DEPRECATED2013",
                |m: &CMsgUpdateItemSchema| { &m.items_game_url_DEPRECATED2013 },
                |m: &mut CMsgUpdateItemSchema| { &mut m.items_game_url_DEPRECATED2013 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "items_game_url",
                |m: &CMsgUpdateItemSchema| { &m.items_game_url },
                |m: &mut CMsgUpdateItemSchema| { &mut m.items_game_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUpdateItemSchema>(
                "CMsgUpdateItemSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUpdateItemSchema {
        static instance: ::protobuf::rt::LazyV2<CMsgUpdateItemSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUpdateItemSchema::new)
    }
}

impl ::protobuf::Clear for CMsgUpdateItemSchema {
    fn clear(&mut self) {
        self.items_game.clear();
        self.item_schema_version = ::std::option::Option::None;
        self.items_game_url_DEPRECATED2013.clear();
        self.items_game_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdateItemSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateItemSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCError {
    // message fields
    error_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCError {
    fn default() -> &'a CMsgGCError {
        <CMsgGCError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCError {
    pub fn new() -> CMsgGCError {
        ::std::default::Default::default()
    }

    // optional string error_text = 1;


    pub fn get_error_text(&self) -> &str {
        match self.error_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_text(&mut self) {
        self.error_text.clear();
    }

    pub fn has_error_text(&self) -> bool {
        self.error_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_text(&mut self, v: ::std::string::String) {
        self.error_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_text(&mut self) -> &mut ::std::string::String {
        if self.error_text.is_none() {
            self.error_text.set_default();
        }
        self.error_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_text(&mut self) -> ::std::string::String {
        self.error_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error_text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error_text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCError {
        CMsgGCError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_text",
                |m: &CMsgGCError| { &m.error_text },
                |m: &mut CMsgGCError| { &mut m.error_text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCError>(
                "CMsgGCError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCError {
        static instance: ::protobuf::rt::LazyV2<CMsgGCError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCError::new)
    }
}

impl ::protobuf::Clear for CMsgGCError {
    fn clear(&mut self) {
        self.error_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestInventoryRefresh {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestInventoryRefresh {
    fn default() -> &'a CMsgRequestInventoryRefresh {
        <CMsgRequestInventoryRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestInventoryRefresh {
    pub fn new() -> CMsgRequestInventoryRefresh {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRequestInventoryRefresh {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestInventoryRefresh {
        CMsgRequestInventoryRefresh::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestInventoryRefresh>(
                "CMsgRequestInventoryRefresh",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestInventoryRefresh {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestInventoryRefresh> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestInventoryRefresh::new)
    }
}

impl ::protobuf::Clear for CMsgRequestInventoryRefresh {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestInventoryRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestInventoryRefresh {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConVarValue {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgConVarValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgConVarValue| { &m.name },
                |m: &mut CMsgConVarValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgConVarValue| { &m.value },
                |m: &mut CMsgConVarValue| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConVarValue>(
                "CMsgConVarValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: ::protobuf::rt::LazyV2<CMsgConVarValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConVarValue::new)
    }
}

impl ::protobuf::Clear for CMsgConVarValue {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConVarValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplicateConVars {
    // message fields
    pub convars: ::protobuf::RepeatedField<CMsgConVarValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }

    // repeated .CMsgConVarValue convars = 1;


    pub fn get_convars(&self) -> &[CMsgConVarValue] {
        &self.convars
    }
    pub fn clear_convars(&mut self) {
        self.convars.clear();
    }

    // Param is passed by value, moved
    pub fn set_convars(&mut self, v: ::protobuf::RepeatedField<CMsgConVarValue>) {
        self.convars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_convars(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConVarValue> {
        &mut self.convars
    }

    // Take field
    pub fn take_convars(&mut self) -> ::protobuf::RepeatedField<CMsgConVarValue> {
        ::std::mem::replace(&mut self.convars, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgReplicateConVars {
    fn is_initialized(&self) -> bool {
        for v in &self.convars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.convars)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.convars {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgConVarValue>>(
                "convars",
                |m: &CMsgReplicateConVars| { &m.convars },
                |m: &mut CMsgReplicateConVars| { &mut m.convars },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplicateConVars>(
                "CMsgReplicateConVars",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: ::protobuf::rt::LazyV2<CMsgReplicateConVars> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplicateConVars::new)
    }
}

impl ::protobuf::Clear for CMsgReplicateConVars {
    fn clear(&mut self) {
        self.convars.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplicateConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplicateConVars {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUseItem {
    // message fields
    item_id: ::std::option::Option<u64>,
    target_steam_id: ::std::option::Option<u64>,
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    duel__class_lock: ::std::option::Option<u32>,
    initiator_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 gift__potential_targets = 3;


    pub fn get_gift__potential_targets(&self) -> &[u32] {
        &self.gift__potential_targets
    }
    pub fn clear_gift__potential_targets(&mut self) {
        self.gift__potential_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_gift__potential_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.gift__potential_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gift__potential_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gift__potential_targets
    }

    // Take field
    pub fn take_gift__potential_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gift__potential_targets, ::std::vec::Vec::new())
    }

    // optional uint32 duel__class_lock = 4;


    pub fn get_duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }
    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 5;


    pub fn get_initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }
    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgUseItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.gift__potential_targets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duel__class_lock = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.initiator_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgUseItem| { &m.item_id },
                |m: &mut CMsgUseItem| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgUseItem| { &m.target_steam_id },
                |m: &mut CMsgUseItem| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gift__potential_targets",
                |m: &CMsgUseItem| { &m.gift__potential_targets },
                |m: &mut CMsgUseItem| { &mut m.gift__potential_targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duel__class_lock",
                |m: &CMsgUseItem| { &m.duel__class_lock },
                |m: &mut CMsgUseItem| { &mut m.duel__class_lock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "initiator_steam_id",
                |m: &CMsgUseItem| { &m.initiator_steam_id },
                |m: &mut CMsgUseItem| { &mut m.initiator_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUseItem>(
                "CMsgUseItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: ::protobuf::rt::LazyV2<CMsgUseItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUseItem::new)
    }
}

impl ::protobuf::Clear for CMsgUseItem {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplayUploadedToYouTube {
    // message fields
    youtube_url: ::protobuf::SingularField<::std::string::String>,
    youtube_account_name: ::protobuf::SingularField<::std::string::String>,
    session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplayUploadedToYouTube {
    fn default() -> &'a CMsgReplayUploadedToYouTube {
        <CMsgReplayUploadedToYouTube as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplayUploadedToYouTube {
    pub fn new() -> CMsgReplayUploadedToYouTube {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;


    pub fn get_youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_url(&mut self) {
        self.youtube_url.clear();
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url.set_default();
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_account_name = 2;


    pub fn get_youtube_account_name(&self) -> &str {
        match self.youtube_account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_account_name(&mut self) {
        self.youtube_account_name.clear();
    }

    pub fn has_youtube_account_name(&self) -> bool {
        self.youtube_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_account_name(&mut self, v: ::std::string::String) {
        self.youtube_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_account_name(&mut self) -> &mut ::std::string::String {
        if self.youtube_account_name.is_none() {
            self.youtube_account_name.set_default();
        }
        self.youtube_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_account_name(&mut self) -> ::std::string::String {
        self.youtube_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 session_id = 3;


    pub fn get_session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReplayUploadedToYouTube {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_account_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.youtube_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.youtube_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.youtube_account_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplayUploadedToYouTube {
        CMsgReplayUploadedToYouTube::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtube_url",
                |m: &CMsgReplayUploadedToYouTube| { &m.youtube_url },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtube_account_name",
                |m: &CMsgReplayUploadedToYouTube| { &m.youtube_account_name },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "session_id",
                |m: &CMsgReplayUploadedToYouTube| { &m.session_id },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplayUploadedToYouTube>(
                "CMsgReplayUploadedToYouTube",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplayUploadedToYouTube {
        static instance: ::protobuf::rt::LazyV2<CMsgReplayUploadedToYouTube> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplayUploadedToYouTube::new)
    }
}

impl ::protobuf::Clear for CMsgReplayUploadedToYouTube {
    fn clear(&mut self) {
        self.youtube_url.clear();
        self.youtube_account_name.clear();
        self.session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplayUploadedToYouTube {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplayUploadedToYouTube {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConsumableExhausted {
    // message fields
    item_def_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableExhausted {
    fn default() -> &'a CMsgConsumableExhausted {
        <CMsgConsumableExhausted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableExhausted {
    pub fn new() -> CMsgConsumableExhausted {
        ::std::default::Default::default()
    }

    // optional int32 item_def_id = 1;


    pub fn get_item_def_id(&self) -> i32 {
        self.item_def_id.unwrap_or(0)
    }
    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: i32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgConsumableExhausted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_def_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConsumableExhausted {
        CMsgConsumableExhausted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "item_def_id",
                |m: &CMsgConsumableExhausted| { &m.item_def_id },
                |m: &mut CMsgConsumableExhausted| { &mut m.item_def_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConsumableExhausted>(
                "CMsgConsumableExhausted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConsumableExhausted {
        static instance: ::protobuf::rt::LazyV2<CMsgConsumableExhausted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConsumableExhausted::new)
    }
}

impl ::protobuf::Clear for CMsgConsumableExhausted {
    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConsumableExhausted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumableExhausted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAcknowledged__DEPRECATED {
    // message fields
    account_id: ::std::option::Option<u32>,
    inventory: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    rarity: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged__DEPRECATED {
    fn default() -> &'a CMsgItemAcknowledged__DEPRECATED {
        <CMsgItemAcknowledged__DEPRECATED as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged__DEPRECATED {
    pub fn new() -> CMsgItemAcknowledged__DEPRECATED {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;


    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }
    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;


    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;


    pub fn get_rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }
    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;


    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }
    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 7;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged__DEPRECATED {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgItemAcknowledged__DEPRECATED {
        CMsgItemAcknowledged__DEPRECATED::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.account_id },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inventory",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.inventory },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.def_index },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.quality },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rarity",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.rarity },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.rarity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.origin },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgItemAcknowledged__DEPRECATED| { &m.item_id },
                |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgItemAcknowledged__DEPRECATED>(
                "CMsgItemAcknowledged__DEPRECATED",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgItemAcknowledged__DEPRECATED {
        static instance: ::protobuf::rt::LazyV2<CMsgItemAcknowledged__DEPRECATED> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgItemAcknowledged__DEPRECATED::new)
    }
}

impl ::protobuf::Clear for CMsgItemAcknowledged__DEPRECATED {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAcknowledged__DEPRECATED {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged__DEPRECATED {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemPositions {
    // message fields
    pub item_positions: ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }

    // repeated .CMsgSetItemPositions.ItemPosition item_positions = 1;


    pub fn get_item_positions(&self) -> &[CMsgSetItemPositions_ItemPosition] {
        &self.item_positions
    }
    pub fn clear_item_positions(&mut self) {
        self.item_positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_positions(&mut self, v: ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition>) {
        self.item_positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_positions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition> {
        &mut self.item_positions
    }

    // Take field
    pub fn take_item_positions(&mut self) -> ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition> {
        ::std::mem::replace(&mut self.item_positions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSetItemPositions {
    fn is_initialized(&self) -> bool {
        for v in &self.item_positions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_positions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_positions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSetItemPositions_ItemPosition>>(
                "item_positions",
                |m: &CMsgSetItemPositions| { &m.item_positions },
                |m: &mut CMsgSetItemPositions| { &mut m.item_positions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemPositions>(
                "CMsgSetItemPositions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemPositions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemPositions::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemPositions {
    fn clear(&mut self) {
        self.item_positions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemPositions_ItemPosition {
    // message fields
    legacy_item_id: ::std::option::Option<u32>,
    position: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions_ItemPosition {
    fn default() -> &'a CMsgSetItemPositions_ItemPosition {
        <CMsgSetItemPositions_ItemPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions_ItemPosition {
    pub fn new() -> CMsgSetItemPositions_ItemPosition {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_item_id = 1;


    pub fn get_legacy_item_id(&self) -> u32 {
        self.legacy_item_id.unwrap_or(0)
    }
    pub fn clear_legacy_item_id(&mut self) {
        self.legacy_item_id = ::std::option::Option::None;
    }

    pub fn has_legacy_item_id(&self) -> bool {
        self.legacy_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_item_id(&mut self, v: u32) {
        self.legacy_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 position = 2;


    pub fn get_position(&self) -> u32 {
        self.position.unwrap_or(0)
    }
    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetItemPositions_ItemPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.position = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_item_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.position {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemPositions_ItemPosition {
        CMsgSetItemPositions_ItemPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_item_id",
                |m: &CMsgSetItemPositions_ItemPosition| { &m.legacy_item_id },
                |m: &mut CMsgSetItemPositions_ItemPosition| { &mut m.legacy_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "position",
                |m: &CMsgSetItemPositions_ItemPosition| { &m.position },
                |m: &mut CMsgSetItemPositions_ItemPosition| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetItemPositions_ItemPosition| { &m.item_id },
                |m: &mut CMsgSetItemPositions_ItemPosition| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemPositions_ItemPosition>(
                "CMsgSetItemPositions.ItemPosition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemPositions_ItemPosition {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemPositions_ItemPosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemPositions_ItemPosition::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemPositions_ItemPosition {
    fn clear(&mut self) {
        self.legacy_item_id = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemPositions_ItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions_ItemPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCReportAbuse {
    // message fields
    target_steam_id: ::std::option::Option<u64>,
    description: ::protobuf::SingularField<::std::string::String>,
    gid: ::std::option::Option<u64>,
    abuse_type: ::std::option::Option<u32>,
    content_type: ::std::option::Option<u32>,
    target_game_server_ip: ::std::option::Option<u32>,
    target_game_server_port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuse {
    fn default() -> &'a CMsgGCReportAbuse {
        <CMsgGCReportAbuse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuse {
    pub fn new() -> CMsgGCReportAbuse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional string description = 4;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gid = 5;


    pub fn get_gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }
    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 abuse_type = 2;


    pub fn get_abuse_type(&self) -> u32 {
        self.abuse_type.unwrap_or(0)
    }
    pub fn clear_abuse_type(&mut self) {
        self.abuse_type = ::std::option::Option::None;
    }

    pub fn has_abuse_type(&self) -> bool {
        self.abuse_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_type(&mut self, v: u32) {
        self.abuse_type = ::std::option::Option::Some(v);
    }

    // optional uint32 content_type = 3;


    pub fn get_content_type(&self) -> u32 {
        self.content_type.unwrap_or(0)
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: u32) {
        self.content_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 target_game_server_ip = 6;


    pub fn get_target_game_server_ip(&self) -> u32 {
        self.target_game_server_ip.unwrap_or(0)
    }
    pub fn clear_target_game_server_ip(&mut self) {
        self.target_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_target_game_server_ip(&self) -> bool {
        self.target_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_ip(&mut self, v: u32) {
        self.target_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 target_game_server_port = 7;


    pub fn get_target_game_server_port(&self) -> u32 {
        self.target_game_server_port.unwrap_or(0)
    }
    pub fn clear_target_game_server_port(&mut self) {
        self.target_game_server_port = ::std::option::Option::None;
    }

    pub fn has_target_game_server_port(&self) -> bool {
        self.target_game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_port(&mut self, v: u32) {
        self.target_game_server_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCReportAbuse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.abuse_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.content_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.target_game_server_ip = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_game_server_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.abuse_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.content_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_game_server_ip {
            my_size += 5;
        }
        if let Some(v) = self.target_game_server_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.gid {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.abuse_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.content_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_game_server_ip {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.target_game_server_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCReportAbuse {
        CMsgGCReportAbuse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgGCReportAbuse| { &m.target_steam_id },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CMsgGCReportAbuse| { &m.description },
                |m: &mut CMsgGCReportAbuse| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gid",
                |m: &CMsgGCReportAbuse| { &m.gid },
                |m: &mut CMsgGCReportAbuse| { &mut m.gid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "abuse_type",
                |m: &CMsgGCReportAbuse| { &m.abuse_type },
                |m: &mut CMsgGCReportAbuse| { &mut m.abuse_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "content_type",
                |m: &CMsgGCReportAbuse| { &m.content_type },
                |m: &mut CMsgGCReportAbuse| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "target_game_server_ip",
                |m: &CMsgGCReportAbuse| { &m.target_game_server_ip },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "target_game_server_port",
                |m: &CMsgGCReportAbuse| { &m.target_game_server_port },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCReportAbuse>(
                "CMsgGCReportAbuse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCReportAbuse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCReportAbuse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCReportAbuse::new)
    }
}

impl ::protobuf::Clear for CMsgGCReportAbuse {
    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.description.clear();
        self.gid = ::std::option::Option::None;
        self.abuse_type = ::std::option::Option::None;
        self.content_type = ::std::option::Option::None;
        self.target_game_server_ip = ::std::option::Option::None;
        self.target_game_server_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCReportAbuse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCReportAbuseResponse {
    // message fields
    target_steam_id: ::std::option::Option<u64>,
    result: ::std::option::Option<u32>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuseResponse {
    fn default() -> &'a CMsgGCReportAbuseResponse {
        <CMsgGCReportAbuseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuseResponse {
    pub fn new() -> CMsgGCReportAbuseResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCReportAbuseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCReportAbuseResponse {
        CMsgGCReportAbuseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgGCReportAbuseResponse| { &m.target_steam_id },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCReportAbuseResponse| { &m.result },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &CMsgGCReportAbuseResponse| { &m.error_message },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCReportAbuseResponse>(
                "CMsgGCReportAbuseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCReportAbuseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCReportAbuseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCReportAbuseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCReportAbuseResponse {
    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCReportAbuseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNameItemNotification {
    // message fields
    player_steamid: ::std::option::Option<u64>,
    item_def_index: ::std::option::Option<u32>,
    item_name_custom: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNameItemNotification {
    fn default() -> &'a CMsgGCNameItemNotification {
        <CMsgGCNameItemNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNameItemNotification {
    pub fn new() -> CMsgGCNameItemNotification {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;


    pub fn get_player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }
    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional string item_name_custom = 3;


    pub fn get_item_name_custom(&self) -> &str {
        match self.item_name_custom.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_name_custom(&mut self) {
        self.item_name_custom.clear();
    }

    pub fn has_item_name_custom(&self) -> bool {
        self.item_name_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name_custom(&mut self, v: ::std::string::String) {
        self.item_name_custom = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name_custom(&mut self) -> &mut ::std::string::String {
        if self.item_name_custom.is_none() {
            self.item_name_custom.set_default();
        }
        self.item_name_custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name_custom(&mut self) -> ::std::string::String {
        self.item_name_custom.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCNameItemNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.player_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_name_custom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 9;
        }
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.item_name_custom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.item_name_custom.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNameItemNotification {
        CMsgGCNameItemNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "player_steamid",
                |m: &CMsgGCNameItemNotification| { &m.player_steamid },
                |m: &mut CMsgGCNameItemNotification| { &mut m.player_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCNameItemNotification| { &m.item_def_index },
                |m: &mut CMsgGCNameItemNotification| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_name_custom",
                |m: &CMsgGCNameItemNotification| { &m.item_name_custom },
                |m: &mut CMsgGCNameItemNotification| { &mut m.item_name_custom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNameItemNotification>(
                "CMsgGCNameItemNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNameItemNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNameItemNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNameItemNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCNameItemNotification {
    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.item_name_custom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNameItemNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNameItemNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientDisplayNotification {
    // message fields
    notification_title_localization_key: ::protobuf::SingularField<::std::string::String>,
    notification_body_localization_key: ::protobuf::SingularField<::std::string::String>,
    pub body_substring_keys: ::protobuf::RepeatedField<::std::string::String>,
    pub body_substring_values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientDisplayNotification {
    fn default() -> &'a CMsgGCClientDisplayNotification {
        <CMsgGCClientDisplayNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientDisplayNotification {
    pub fn new() -> CMsgGCClientDisplayNotification {
        ::std::default::Default::default()
    }

    // optional string notification_title_localization_key = 1;


    pub fn get_notification_title_localization_key(&self) -> &str {
        match self.notification_title_localization_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_title_localization_key(&mut self) {
        self.notification_title_localization_key.clear();
    }

    pub fn has_notification_title_localization_key(&self) -> bool {
        self.notification_title_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_title_localization_key(&mut self, v: ::std::string::String) {
        self.notification_title_localization_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_title_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_title_localization_key.is_none() {
            self.notification_title_localization_key.set_default();
        }
        self.notification_title_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_title_localization_key(&mut self) -> ::std::string::String {
        self.notification_title_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string notification_body_localization_key = 2;


    pub fn get_notification_body_localization_key(&self) -> &str {
        match self.notification_body_localization_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_body_localization_key(&mut self) {
        self.notification_body_localization_key.clear();
    }

    pub fn has_notification_body_localization_key(&self) -> bool {
        self.notification_body_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_body_localization_key(&mut self, v: ::std::string::String) {
        self.notification_body_localization_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_body_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_body_localization_key.is_none() {
            self.notification_body_localization_key.set_default();
        }
        self.notification_body_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_body_localization_key(&mut self) -> ::std::string::String {
        self.notification_body_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string body_substring_keys = 3;


    pub fn get_body_substring_keys(&self) -> &[::std::string::String] {
        &self.body_substring_keys
    }
    pub fn clear_body_substring_keys(&mut self) {
        self.body_substring_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_substring_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_substring_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_substring_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_substring_keys
    }

    // Take field
    pub fn take_body_substring_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_substring_keys, ::protobuf::RepeatedField::new())
    }

    // repeated string body_substring_values = 4;


    pub fn get_body_substring_values(&self) -> &[::std::string::String] {
        &self.body_substring_values
    }
    pub fn clear_body_substring_values(&mut self) {
        self.body_substring_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_substring_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_substring_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_substring_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_substring_values
    }

    // Take field
    pub fn take_body_substring_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_substring_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCClientDisplayNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_title_localization_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_body_localization_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_substring_keys)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_substring_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.notification_title_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.notification_body_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.body_substring_keys {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.body_substring_values {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.notification_title_localization_key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.notification_body_localization_key.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.body_substring_keys {
            os.write_string(3, &v)?;
        };
        for v in &self.body_substring_values {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientDisplayNotification {
        CMsgGCClientDisplayNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_title_localization_key",
                |m: &CMsgGCClientDisplayNotification| { &m.notification_title_localization_key },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_title_localization_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_body_localization_key",
                |m: &CMsgGCClientDisplayNotification| { &m.notification_body_localization_key },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_body_localization_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_substring_keys",
                |m: &CMsgGCClientDisplayNotification| { &m.body_substring_keys },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_substring_values",
                |m: &CMsgGCClientDisplayNotification| { &m.body_substring_values },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientDisplayNotification>(
                "CMsgGCClientDisplayNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientDisplayNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientDisplayNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientDisplayNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientDisplayNotification {
    fn clear(&mut self) {
        self.notification_title_localization_key.clear();
        self.notification_body_localization_key.clear();
        self.body_substring_keys.clear();
        self.body_substring_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientDisplayNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientDisplayNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCShowItemsPickedUp {
    // message fields
    player_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCShowItemsPickedUp {
    fn default() -> &'a CMsgGCShowItemsPickedUp {
        <CMsgGCShowItemsPickedUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShowItemsPickedUp {
    pub fn new() -> CMsgGCShowItemsPickedUp {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;


    pub fn get_player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }
    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCShowItemsPickedUp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.player_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCShowItemsPickedUp {
        CMsgGCShowItemsPickedUp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "player_steamid",
                |m: &CMsgGCShowItemsPickedUp| { &m.player_steamid },
                |m: &mut CMsgGCShowItemsPickedUp| { &mut m.player_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCShowItemsPickedUp>(
                "CMsgGCShowItemsPickedUp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCShowItemsPickedUp {
        static instance: ::protobuf::rt::LazyV2<CMsgGCShowItemsPickedUp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCShowItemsPickedUp::new)
    }
}

impl ::protobuf::Clear for CMsgGCShowItemsPickedUp {
    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCShowItemsPickedUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShowItemsPickedUp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCIncrementKillCountResponse {
    // message fields
    killer_account_id: ::std::option::Option<u32>,
    num_kills: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    level_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCIncrementKillCountResponse {
    fn default() -> &'a CMsgGCIncrementKillCountResponse {
        <CMsgGCIncrementKillCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCIncrementKillCountResponse {
    pub fn new() -> CMsgGCIncrementKillCountResponse {
        ::std::default::Default::default()
    }

    // optional uint32 killer_account_id = 1;


    pub fn get_killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }
    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_kills = 2;


    pub fn get_num_kills(&self) -> u32 {
        self.num_kills.unwrap_or(0)
    }
    pub fn clear_num_kills(&mut self) {
        self.num_kills = ::std::option::Option::None;
    }

    pub fn has_num_kills(&self) -> bool {
        self.num_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_kills(&mut self, v: u32) {
        self.num_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;


    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }
    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 level_type = 4;


    pub fn get_level_type(&self) -> u32 {
        self.level_type.unwrap_or(0)
    }
    pub fn clear_level_type(&mut self) {
        self.level_type = ::std::option::Option::None;
    }

    pub fn has_level_type(&self) -> bool {
        self.level_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_type(&mut self, v: u32) {
        self.level_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCIncrementKillCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killer_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_kills {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.level_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCIncrementKillCountResponse {
        CMsgGCIncrementKillCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "killer_account_id",
                |m: &CMsgGCIncrementKillCountResponse| { &m.killer_account_id },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.killer_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_kills",
                |m: &CMsgGCIncrementKillCountResponse| { &m.num_kills },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.num_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def",
                |m: &CMsgGCIncrementKillCountResponse| { &m.item_def },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level_type",
                |m: &CMsgGCIncrementKillCountResponse| { &m.level_type },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.level_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCIncrementKillCountResponse>(
                "CMsgGCIncrementKillCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCIncrementKillCountResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCIncrementKillCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCIncrementKillCountResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCIncrementKillCountResponse {
    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.num_kills = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.level_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCIncrementKillCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIncrementKillCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemDropRateBonus {
    // message fields
    account_id: ::std::option::Option<u32>,
    expiration_date: ::std::option::Option<u32>,
    bonus: ::std::option::Option<f32>,
    bonus_count: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    def_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemDropRateBonus {
    fn default() -> &'a CSOEconItemDropRateBonus {
        <CSOEconItemDropRateBonus as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemDropRateBonus {
    pub fn new() -> CSOEconItemDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 2;


    pub fn get_expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }
    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    // optional float bonus = 3;


    pub fn get_bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }
    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_count = 4;


    pub fn get_bonus_count(&self) -> u32 {
        self.bonus_count.unwrap_or(0)
    }
    pub fn clear_bonus_count(&mut self) {
        self.bonus_count = ::std::option::Option::None;
    }

    pub fn has_bonus_count(&self) -> bool {
        self.bonus_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_count(&mut self, v: u32) {
        self.bonus_count = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 6;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemDropRateBonus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.expiration_date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bonus = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_date {
            my_size += 5;
        }
        if let Some(v) = self.bonus {
            my_size += 5;
        }
        if let Some(v) = self.bonus_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemDropRateBonus {
        CSOEconItemDropRateBonus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconItemDropRateBonus| { &m.account_id },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "expiration_date",
                |m: &CSOEconItemDropRateBonus| { &m.expiration_date },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.expiration_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bonus",
                |m: &CSOEconItemDropRateBonus| { &m.bonus },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bonus_count",
                |m: &CSOEconItemDropRateBonus| { &m.bonus_count },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CSOEconItemDropRateBonus| { &m.item_id },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOEconItemDropRateBonus| { &m.def_index },
                |m: &mut CSOEconItemDropRateBonus| { &mut m.def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemDropRateBonus>(
                "CSOEconItemDropRateBonus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemDropRateBonus {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemDropRateBonus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemDropRateBonus::new)
    }
}

impl ::protobuf::Clear for CSOEconItemDropRateBonus {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.bonus_count = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemDropRateBonus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemLeagueViewPass {
    // message fields
    account_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    admin: ::std::option::Option<u32>,
    itemindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemLeagueViewPass {
    fn default() -> &'a CSOEconItemLeagueViewPass {
        <CSOEconItemLeagueViewPass as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemLeagueViewPass {
    pub fn new() -> CSOEconItemLeagueViewPass {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;


    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }
    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 admin = 3;


    pub fn get_admin(&self) -> u32 {
        self.admin.unwrap_or(0)
    }
    pub fn clear_admin(&mut self) {
        self.admin = ::std::option::Option::None;
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: u32) {
        self.admin = ::std::option::Option::Some(v);
    }

    // optional uint32 itemindex = 4;


    pub fn get_itemindex(&self) -> u32 {
        self.itemindex.unwrap_or(0)
    }
    pub fn clear_itemindex(&mut self) {
        self.itemindex = ::std::option::Option::None;
    }

    pub fn has_itemindex(&self) -> bool {
        self.itemindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemindex(&mut self, v: u32) {
        self.itemindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemLeagueViewPass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.admin = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.itemindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.admin {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemindex {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.admin {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.itemindex {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemLeagueViewPass {
        CSOEconItemLeagueViewPass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconItemLeagueViewPass| { &m.account_id },
                |m: &mut CSOEconItemLeagueViewPass| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "league_id",
                |m: &CSOEconItemLeagueViewPass| { &m.league_id },
                |m: &mut CSOEconItemLeagueViewPass| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "admin",
                |m: &CSOEconItemLeagueViewPass| { &m.admin },
                |m: &mut CSOEconItemLeagueViewPass| { &mut m.admin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "itemindex",
                |m: &CSOEconItemLeagueViewPass| { &m.itemindex },
                |m: &mut CSOEconItemLeagueViewPass| { &mut m.itemindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemLeagueViewPass>(
                "CSOEconItemLeagueViewPass",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemLeagueViewPass {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemLeagueViewPass> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemLeagueViewPass::new)
    }
}

impl ::protobuf::Clear for CSOEconItemLeagueViewPass {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.admin = ::std::option::Option::None;
        self.itemindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemLeagueViewPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemLeagueViewPass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemEventTicket {
    // message fields
    account_id: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEventTicket {
    fn default() -> &'a CSOEconItemEventTicket {
        <CSOEconItemEventTicket as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEventTicket {
    pub fn new() -> CSOEconItemEventTicket {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;


    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemEventTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemEventTicket {
        CSOEconItemEventTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconItemEventTicket| { &m.account_id },
                |m: &mut CSOEconItemEventTicket| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_id",
                |m: &CSOEconItemEventTicket| { &m.event_id },
                |m: &mut CSOEconItemEventTicket| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CSOEconItemEventTicket| { &m.item_id },
                |m: &mut CSOEconItemEventTicket| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemEventTicket>(
                "CSOEconItemEventTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemEventTicket {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemEventTicket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemEventTicket::new)
    }
}

impl ::protobuf::Clear for CSOEconItemEventTicket {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemEventTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEventTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemPreviewItemBoughtNotification {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemPreviewItemBoughtNotification {
    fn default() -> &'a CMsgGCItemPreviewItemBoughtNotification {
        <CMsgGCItemPreviewItemBoughtNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemPreviewItemBoughtNotification {
    pub fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCItemPreviewItemBoughtNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        CMsgGCItemPreviewItemBoughtNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCItemPreviewItemBoughtNotification| { &m.item_def_index },
                |m: &mut CMsgGCItemPreviewItemBoughtNotification| { &mut m.item_def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCItemPreviewItemBoughtNotification>(
                "CMsgGCItemPreviewItemBoughtNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCItemPreviewItemBoughtNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCItemPreviewItemBoughtNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCItemPreviewItemBoughtNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCItemPreviewItemBoughtNotification {
    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemPreviewItemBoughtNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemPreviewItemBoughtNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    txn_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseCancel| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseCancel| { &mut m.txn_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseCancel>(
                "CMsgGCStorePurchaseCancel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseCancel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseCancel::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseCancel {
    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCStorePurchaseCancelResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseCancelResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseCancelResponse>(
                "CMsgGCStorePurchaseCancelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseCancelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseCancelResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseCancelResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    txn_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseFinalize| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseFinalize| { &mut m.txn_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseFinalize>(
                "CMsgGCStorePurchaseFinalize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseFinalize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseFinalize::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseFinalize {
    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    result: ::std::option::Option<u32>,
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // repeated uint64 item_ids = 2;


    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }
    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_ids",
                |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.item_ids },
                |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.item_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseFinalizeResponse>(
                "CMsgGCStorePurchaseFinalizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseFinalizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseFinalizeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseFinalizeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseFinalizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBannedWordListRequest {
    // message fields
    ban_list_group_id: ::std::option::Option<u32>,
    word_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListRequest {
    fn default() -> &'a CMsgGCBannedWordListRequest {
        <CMsgGCBannedWordListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListRequest {
    pub fn new() -> CMsgGCBannedWordListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;


    pub fn get_ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }
    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 word_id = 2;


    pub fn get_word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }
    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ban_list_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.word_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCBannedWordListRequest {
        CMsgGCBannedWordListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ban_list_group_id",
                |m: &CMsgGCBannedWordListRequest| { &m.ban_list_group_id },
                |m: &mut CMsgGCBannedWordListRequest| { &mut m.ban_list_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "word_id",
                |m: &CMsgGCBannedWordListRequest| { &m.word_id },
                |m: &mut CMsgGCBannedWordListRequest| { &mut m.word_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCBannedWordListRequest>(
                "CMsgGCBannedWordListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCBannedWordListRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCBannedWordListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCBannedWordListRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCBannedWordListRequest {
    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBannedWordListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestAnnouncements {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestAnnouncements {
    fn default() -> &'a CMsgGCRequestAnnouncements {
        <CMsgGCRequestAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestAnnouncements {
    pub fn new() -> CMsgGCRequestAnnouncements {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCRequestAnnouncements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestAnnouncements {
        CMsgGCRequestAnnouncements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestAnnouncements>(
                "CMsgGCRequestAnnouncements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestAnnouncements {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestAnnouncements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestAnnouncements::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestAnnouncements {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestAnnouncements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestAnnouncementsResponse {
    // message fields
    announcement_title: ::protobuf::SingularField<::std::string::String>,
    announcement: ::protobuf::SingularField<::std::string::String>,
    nextmatch_title: ::protobuf::SingularField<::std::string::String>,
    nextmatch: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestAnnouncementsResponse {
    fn default() -> &'a CMsgGCRequestAnnouncementsResponse {
        <CMsgGCRequestAnnouncementsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestAnnouncementsResponse {
    pub fn new() -> CMsgGCRequestAnnouncementsResponse {
        ::std::default::Default::default()
    }

    // optional string announcement_title = 1;


    pub fn get_announcement_title(&self) -> &str {
        match self.announcement_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_title(&mut self) {
        self.announcement_title.clear();
    }

    pub fn has_announcement_title(&self) -> bool {
        self.announcement_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_title(&mut self, v: ::std::string::String) {
        self.announcement_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_title(&mut self) -> &mut ::std::string::String {
        if self.announcement_title.is_none() {
            self.announcement_title.set_default();
        }
        self.announcement_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_title(&mut self) -> ::std::string::String {
        self.announcement_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement = 2;


    pub fn get_announcement(&self) -> &str {
        match self.announcement.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement(&mut self) {
        self.announcement.clear();
    }

    pub fn has_announcement(&self) -> bool {
        self.announcement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: ::std::string::String) {
        self.announcement = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement(&mut self) -> &mut ::std::string::String {
        if self.announcement.is_none() {
            self.announcement.set_default();
        }
        self.announcement.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement(&mut self) -> ::std::string::String {
        self.announcement.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nextmatch_title = 3;


    pub fn get_nextmatch_title(&self) -> &str {
        match self.nextmatch_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nextmatch_title(&mut self) {
        self.nextmatch_title.clear();
    }

    pub fn has_nextmatch_title(&self) -> bool {
        self.nextmatch_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextmatch_title(&mut self, v: ::std::string::String) {
        self.nextmatch_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nextmatch_title(&mut self) -> &mut ::std::string::String {
        if self.nextmatch_title.is_none() {
            self.nextmatch_title.set_default();
        }
        self.nextmatch_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_nextmatch_title(&mut self) -> ::std::string::String {
        self.nextmatch_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nextmatch = 4;


    pub fn get_nextmatch(&self) -> &str {
        match self.nextmatch.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nextmatch(&mut self) {
        self.nextmatch.clear();
    }

    pub fn has_nextmatch(&self) -> bool {
        self.nextmatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextmatch(&mut self, v: ::std::string::String) {
        self.nextmatch = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nextmatch(&mut self) -> &mut ::std::string::String {
        if self.nextmatch.is_none() {
            self.nextmatch.set_default();
        }
        self.nextmatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_nextmatch(&mut self) -> ::std::string::String {
        self.nextmatch.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCRequestAnnouncementsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextmatch_title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextmatch)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.announcement_title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.announcement.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.nextmatch_title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.nextmatch.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.announcement_title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.announcement.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.nextmatch_title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.nextmatch.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestAnnouncementsResponse {
        CMsgGCRequestAnnouncementsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement_title",
                |m: &CMsgGCRequestAnnouncementsResponse| { &m.announcement_title },
                |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.announcement_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement",
                |m: &CMsgGCRequestAnnouncementsResponse| { &m.announcement },
                |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.announcement },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextmatch_title",
                |m: &CMsgGCRequestAnnouncementsResponse| { &m.nextmatch_title },
                |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.nextmatch_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextmatch",
                |m: &CMsgGCRequestAnnouncementsResponse| { &m.nextmatch },
                |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.nextmatch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestAnnouncementsResponse>(
                "CMsgGCRequestAnnouncementsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestAnnouncementsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestAnnouncementsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestAnnouncementsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestAnnouncementsResponse {
    fn clear(&mut self) {
        self.announcement_title.clear();
        self.announcement.clear();
        self.nextmatch_title.clear();
        self.nextmatch.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestAnnouncementsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestAnnouncementsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBannedWord {
    // message fields
    word_id: ::std::option::Option<u32>,
    word_type: ::std::option::Option<GC_BannedWordType>,
    word: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWord {
    fn default() -> &'a CMsgGCBannedWord {
        <CMsgGCBannedWord as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWord {
    pub fn new() -> CMsgGCBannedWord {
        ::std::default::Default::default()
    }

    // optional uint32 word_id = 1;


    pub fn get_word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }
    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }

    // optional .GC_BannedWordType word_type = 2;


    pub fn get_word_type(&self) -> GC_BannedWordType {
        self.word_type.unwrap_or(GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD)
    }
    pub fn clear_word_type(&mut self) {
        self.word_type = ::std::option::Option::None;
    }

    pub fn has_word_type(&self) -> bool {
        self.word_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_type(&mut self, v: GC_BannedWordType) {
        self.word_type = ::std::option::Option::Some(v);
    }

    // optional string word = 3;


    pub fn get_word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_word(&mut self) {
        self.word.clear();
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word.set_default();
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCBannedWord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.word_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.word_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.word)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.word_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.word_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.word.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCBannedWord {
        CMsgGCBannedWord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "word_id",
                |m: &CMsgGCBannedWord| { &m.word_id },
                |m: &mut CMsgGCBannedWord| { &mut m.word_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GC_BannedWordType>>(
                "word_type",
                |m: &CMsgGCBannedWord| { &m.word_type },
                |m: &mut CMsgGCBannedWord| { &mut m.word_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "word",
                |m: &CMsgGCBannedWord| { &m.word },
                |m: &mut CMsgGCBannedWord| { &mut m.word },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCBannedWord>(
                "CMsgGCBannedWord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCBannedWord {
        static instance: ::protobuf::rt::LazyV2<CMsgGCBannedWord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCBannedWord::new)
    }
}

impl ::protobuf::Clear for CMsgGCBannedWord {
    fn clear(&mut self) {
        self.word_id = ::std::option::Option::None;
        self.word_type = ::std::option::Option::None;
        self.word.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBannedWord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBannedWordListResponse {
    // message fields
    ban_list_group_id: ::std::option::Option<u32>,
    pub word_list: ::protobuf::RepeatedField<CMsgGCBannedWord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListResponse {
    fn default() -> &'a CMsgGCBannedWordListResponse {
        <CMsgGCBannedWordListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListResponse {
    pub fn new() -> CMsgGCBannedWordListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;


    pub fn get_ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }
    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCBannedWord word_list = 2;


    pub fn get_word_list(&self) -> &[CMsgGCBannedWord] {
        &self.word_list
    }
    pub fn clear_word_list(&mut self) {
        self.word_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_word_list(&mut self, v: ::protobuf::RepeatedField<CMsgGCBannedWord>) {
        self.word_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_word_list(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCBannedWord> {
        &mut self.word_list
    }

    // Take field
    pub fn take_word_list(&mut self) -> ::protobuf::RepeatedField<CMsgGCBannedWord> {
        ::std::mem::replace(&mut self.word_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.word_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ban_list_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.word_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.word_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.word_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCBannedWordListResponse {
        CMsgGCBannedWordListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ban_list_group_id",
                |m: &CMsgGCBannedWordListResponse| { &m.ban_list_group_id },
                |m: &mut CMsgGCBannedWordListResponse| { &mut m.ban_list_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCBannedWord>>(
                "word_list",
                |m: &CMsgGCBannedWordListResponse| { &m.word_list },
                |m: &mut CMsgGCBannedWordListResponse| { &mut m.word_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCBannedWordListResponse>(
                "CMsgGCBannedWordListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCBannedWordListResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCBannedWordListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCBannedWordListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCBannedWordListResponse {
    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBannedWordListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCBannedWordListBroadcast {
    // message fields
    pub broadcast: ::protobuf::SingularPtrField<CMsgGCBannedWordListResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListBroadcast {
    fn default() -> &'a CMsgGCToGCBannedWordListBroadcast {
        <CMsgGCToGCBannedWordListBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListBroadcast {
    pub fn new() -> CMsgGCToGCBannedWordListBroadcast {
        ::std::default::Default::default()
    }

    // optional .CMsgGCBannedWordListResponse broadcast = 1;


    pub fn get_broadcast(&self) -> &CMsgGCBannedWordListResponse {
        self.broadcast.as_ref().unwrap_or_else(|| <CMsgGCBannedWordListResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_broadcast(&mut self) {
        self.broadcast.clear();
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: CMsgGCBannedWordListResponse) {
        self.broadcast = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast(&mut self) -> &mut CMsgGCBannedWordListResponse {
        if self.broadcast.is_none() {
            self.broadcast.set_default();
        }
        self.broadcast.as_mut().unwrap()
    }

    // Take field
    pub fn take_broadcast(&mut self) -> CMsgGCBannedWordListResponse {
        self.broadcast.take().unwrap_or_else(|| CMsgGCBannedWordListResponse::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCBannedWordListBroadcast {
    fn is_initialized(&self) -> bool {
        for v in &self.broadcast {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.broadcast)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.broadcast.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCBannedWordListBroadcast {
        CMsgGCToGCBannedWordListBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCBannedWordListResponse>>(
                "broadcast",
                |m: &CMsgGCToGCBannedWordListBroadcast| { &m.broadcast },
                |m: &mut CMsgGCToGCBannedWordListBroadcast| { &mut m.broadcast },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCBannedWordListBroadcast>(
                "CMsgGCToGCBannedWordListBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCBannedWordListBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCBannedWordListBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCBannedWordListBroadcast {
    fn clear(&mut self) {
        self.broadcast.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCBannedWordListBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBannedWordListBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCBannedWordListUpdated {
    // message fields
    group_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListUpdated {
    fn default() -> &'a CMsgGCToGCBannedWordListUpdated {
        <CMsgGCToGCBannedWordListUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListUpdated {
    pub fn new() -> CMsgGCToGCBannedWordListUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 group_id = 1;


    pub fn get_group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCBannedWordListUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCBannedWordListUpdated {
        CMsgGCToGCBannedWordListUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "group_id",
                |m: &CMsgGCToGCBannedWordListUpdated| { &m.group_id },
                |m: &mut CMsgGCToGCBannedWordListUpdated| { &mut m.group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCBannedWordListUpdated>(
                "CMsgGCToGCBannedWordListUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListUpdated {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCBannedWordListUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCBannedWordListUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCBannedWordListUpdated {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCBannedWordListUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBannedWordListUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconDefaultEquippedDefinitionInstanceClient {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_definition: ::std::option::Option<u32>,
    class_id: ::std::option::Option<u32>,
    slot_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconDefaultEquippedDefinitionInstanceClient {
    fn default() -> &'a CSOEconDefaultEquippedDefinitionInstanceClient {
        <CSOEconDefaultEquippedDefinitionInstanceClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconDefaultEquippedDefinitionInstanceClient {
    pub fn new() -> CSOEconDefaultEquippedDefinitionInstanceClient {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_definition = 2;


    pub fn get_item_definition(&self) -> u32 {
        self.item_definition.unwrap_or(0)
    }
    pub fn clear_item_definition(&mut self) {
        self.item_definition = ::std::option::Option::None;
    }

    pub fn has_item_definition(&self) -> bool {
        self.item_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition(&mut self, v: u32) {
        self.item_definition = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 3;


    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 4;


    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }
    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_definition = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_definition {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_definition {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconDefaultEquippedDefinitionInstanceClient {
        CSOEconDefaultEquippedDefinitionInstanceClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.account_id },
                |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_definition",
                |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.item_definition },
                |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.item_definition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_id",
                |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.class_id },
                |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot_id",
                |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.slot_id },
                |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.slot_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconDefaultEquippedDefinitionInstanceClient>(
                "CSOEconDefaultEquippedDefinitionInstanceClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconDefaultEquippedDefinitionInstanceClient {
        static instance: ::protobuf::rt::LazyV2<CSOEconDefaultEquippedDefinitionInstanceClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconDefaultEquippedDefinitionInstanceClient::new)
    }
}

impl ::protobuf::Clear for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_definition = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCDirtySDOCache {
    // message fields
    sdo_type: ::std::option::Option<u32>,
    key_uint64: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtySDOCache {
    fn default() -> &'a CMsgGCToGCDirtySDOCache {
        <CMsgGCToGCDirtySDOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtySDOCache {
    pub fn new() -> CMsgGCToGCDirtySDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;


    pub fn get_sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }
    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    // optional uint64 key_uint64 = 2;


    pub fn get_key_uint64(&self) -> u64 {
        self.key_uint64.unwrap_or(0)
    }
    pub fn clear_key_uint64(&mut self) {
        self.key_uint64 = ::std::option::Option::None;
    }

    pub fn has_key_uint64(&self) -> bool {
        self.key_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_uint64(&mut self, v: u64) {
        self.key_uint64 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCDirtySDOCache {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sdo_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.key_uint64 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key_uint64 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key_uint64 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCDirtySDOCache {
        CMsgGCToGCDirtySDOCache::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sdo_type",
                |m: &CMsgGCToGCDirtySDOCache| { &m.sdo_type },
                |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.sdo_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "key_uint64",
                |m: &CMsgGCToGCDirtySDOCache| { &m.key_uint64 },
                |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.key_uint64 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCDirtySDOCache>(
                "CMsgGCToGCDirtySDOCache",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCDirtySDOCache {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCDirtySDOCache> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCDirtySDOCache::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCDirtySDOCache {
    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCDirtySDOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCDirtySDOCache {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCDirtyMultipleSDOCache {
    // message fields
    sdo_type: ::std::option::Option<u32>,
    pub key_uint64: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtyMultipleSDOCache {
    fn default() -> &'a CMsgGCToGCDirtyMultipleSDOCache {
        <CMsgGCToGCDirtyMultipleSDOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtyMultipleSDOCache {
    pub fn new() -> CMsgGCToGCDirtyMultipleSDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;


    pub fn get_sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }
    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    // repeated uint64 key_uint64 = 2;


    pub fn get_key_uint64(&self) -> &[u64] {
        &self.key_uint64
    }
    pub fn clear_key_uint64(&mut self) {
        self.key_uint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_uint64(&mut self, v: ::std::vec::Vec<u64>) {
        self.key_uint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.key_uint64
    }

    // Take field
    pub fn take_key_uint64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.key_uint64, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCDirtyMultipleSDOCache {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sdo_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.key_uint64)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.key_uint64 {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        for v in &self.key_uint64 {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCDirtyMultipleSDOCache {
        CMsgGCToGCDirtyMultipleSDOCache::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sdo_type",
                |m: &CMsgGCToGCDirtyMultipleSDOCache| { &m.sdo_type },
                |m: &mut CMsgGCToGCDirtyMultipleSDOCache| { &mut m.sdo_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "key_uint64",
                |m: &CMsgGCToGCDirtyMultipleSDOCache| { &m.key_uint64 },
                |m: &mut CMsgGCToGCDirtyMultipleSDOCache| { &mut m.key_uint64 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCDirtyMultipleSDOCache>(
                "CMsgGCToGCDirtyMultipleSDOCache",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCDirtyMultipleSDOCache {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCDirtyMultipleSDOCache> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCDirtyMultipleSDOCache::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCDirtyMultipleSDOCache {
    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCDirtyMultipleSDOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCDirtyMultipleSDOCache {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCollectItem {
    // message fields
    collection_item_id: ::std::option::Option<u64>,
    subject_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCollectItem {
    fn default() -> &'a CMsgGCCollectItem {
        <CMsgGCCollectItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCollectItem {
    pub fn new() -> CMsgGCCollectItem {
        ::std::default::Default::default()
    }

    // optional uint64 collection_item_id = 1;


    pub fn get_collection_item_id(&self) -> u64 {
        self.collection_item_id.unwrap_or(0)
    }
    pub fn clear_collection_item_id(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
    }

    pub fn has_collection_item_id(&self) -> bool {
        self.collection_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_item_id(&mut self, v: u64) {
        self.collection_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;


    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }
    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCollectItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.collection_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.collection_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.collection_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCollectItem {
        CMsgGCCollectItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "collection_item_id",
                |m: &CMsgGCCollectItem| { &m.collection_item_id },
                |m: &mut CMsgGCCollectItem| { &mut m.collection_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "subject_item_id",
                |m: &CMsgGCCollectItem| { &m.subject_item_id },
                |m: &mut CMsgGCCollectItem| { &mut m.subject_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCCollectItem>(
                "CMsgGCCollectItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCCollectItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGCCollectItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCCollectItem::new)
    }
}

impl ::protobuf::Clear for CMsgGCCollectItem {
    fn clear(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCollectItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCollectItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSDONoMemcached {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSDONoMemcached {
    fn default() -> &'a CMsgSDONoMemcached {
        <CMsgSDONoMemcached as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDONoMemcached {
    pub fn new() -> CMsgSDONoMemcached {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSDONoMemcached {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSDONoMemcached {
        CMsgSDONoMemcached::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSDONoMemcached>(
                "CMsgSDONoMemcached",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSDONoMemcached {
        static instance: ::protobuf::rt::LazyV2<CMsgSDONoMemcached> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSDONoMemcached::new)
    }
}

impl ::protobuf::Clear for CMsgSDONoMemcached {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSDONoMemcached {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDONoMemcached {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCUpdateSQLKeyValue {
    // message fields
    key_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSQLKeyValue {
    fn default() -> &'a CMsgGCToGCUpdateSQLKeyValue {
        <CMsgGCToGCUpdateSQLKeyValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSQLKeyValue {
    pub fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        ::std::default::Default::default()
    }

    // optional string key_name = 1;


    pub fn get_key_name(&self) -> &str {
        match self.key_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key_name(&mut self) {
        self.key_name.clear();
    }

    pub fn has_key_name(&self) -> bool {
        self.key_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_name(&mut self, v: ::std::string::String) {
        self.key_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_name(&mut self) -> &mut ::std::string::String {
        if self.key_name.is_none() {
            self.key_name.set_default();
        }
        self.key_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_name(&mut self) -> ::std::string::String {
        self.key_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateSQLKeyValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        CMsgGCToGCUpdateSQLKeyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_name",
                |m: &CMsgGCToGCUpdateSQLKeyValue| { &m.key_name },
                |m: &mut CMsgGCToGCUpdateSQLKeyValue| { &mut m.key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCUpdateSQLKeyValue>(
                "CMsgGCToGCUpdateSQLKeyValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSQLKeyValue {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCUpdateSQLKeyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCUpdateSQLKeyValue::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCUpdateSQLKeyValue {
    fn clear(&mut self) {
        self.key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCUpdateSQLKeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateSQLKeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCIsTrustedServer {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIsTrustedServer {
    fn default() -> &'a CMsgGCToGCIsTrustedServer {
        <CMsgGCToGCIsTrustedServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIsTrustedServer {
    pub fn new() -> CMsgGCToGCIsTrustedServer {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCIsTrustedServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCIsTrustedServer {
        CMsgGCToGCIsTrustedServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGCToGCIsTrustedServer| { &m.steam_id },
                |m: &mut CMsgGCToGCIsTrustedServer| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCIsTrustedServer>(
                "CMsgGCToGCIsTrustedServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCIsTrustedServer {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCIsTrustedServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCIsTrustedServer::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCIsTrustedServer {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCIsTrustedServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIsTrustedServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCIsTrustedServerResponse {
    // message fields
    is_trusted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIsTrustedServerResponse {
    fn default() -> &'a CMsgGCToGCIsTrustedServerResponse {
        <CMsgGCToGCIsTrustedServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIsTrustedServerResponse {
    pub fn new() -> CMsgGCToGCIsTrustedServerResponse {
        ::std::default::Default::default()
    }

    // optional bool is_trusted = 1;


    pub fn get_is_trusted(&self) -> bool {
        self.is_trusted.unwrap_or(false)
    }
    pub fn clear_is_trusted(&mut self) {
        self.is_trusted = ::std::option::Option::None;
    }

    pub fn has_is_trusted(&self) -> bool {
        self.is_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trusted(&mut self, v: bool) {
        self.is_trusted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCIsTrustedServerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_trusted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_trusted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_trusted {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCIsTrustedServerResponse {
        CMsgGCToGCIsTrustedServerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_trusted",
                |m: &CMsgGCToGCIsTrustedServerResponse| { &m.is_trusted },
                |m: &mut CMsgGCToGCIsTrustedServerResponse| { &mut m.is_trusted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCIsTrustedServerResponse>(
                "CMsgGCToGCIsTrustedServerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCIsTrustedServerResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCIsTrustedServerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCIsTrustedServerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCIsTrustedServerResponse {
    fn clear(&mut self) {
        self.is_trusted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCIsTrustedServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIsTrustedServerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCBroadcastConsoleCommand {
    // message fields
    con_command: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastConsoleCommand {
    fn default() -> &'a CMsgGCToGCBroadcastConsoleCommand {
        <CMsgGCToGCBroadcastConsoleCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastConsoleCommand {
    pub fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        ::std::default::Default::default()
    }

    // optional string con_command = 1;


    pub fn get_con_command(&self) -> &str {
        match self.con_command.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_con_command(&mut self) {
        self.con_command.clear();
    }

    pub fn has_con_command(&self) -> bool {
        self.con_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con_command(&mut self, v: ::std::string::String) {
        self.con_command = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con_command(&mut self) -> &mut ::std::string::String {
        if self.con_command.is_none() {
            self.con_command.set_default();
        }
        self.con_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_con_command(&mut self) -> ::std::string::String {
        self.con_command.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCBroadcastConsoleCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.con_command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.con_command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.con_command.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        CMsgGCToGCBroadcastConsoleCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "con_command",
                |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.con_command },
                |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.con_command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCBroadcastConsoleCommand>(
                "CMsgGCToGCBroadcastConsoleCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastConsoleCommand {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCBroadcastConsoleCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCBroadcastConsoleCommand::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCBroadcastConsoleCommand {
    fn clear(&mut self) {
        self.con_command.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCBroadcastConsoleCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBroadcastConsoleCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCServerVersionUpdated {
    // message fields
    server_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCServerVersionUpdated {
    fn default() -> &'a CMsgGCServerVersionUpdated {
        <CMsgGCServerVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCServerVersionUpdated {
    pub fn new() -> CMsgGCServerVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCServerVersionUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCServerVersionUpdated {
        CMsgGCServerVersionUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_version",
                |m: &CMsgGCServerVersionUpdated| { &m.server_version },
                |m: &mut CMsgGCServerVersionUpdated| { &mut m.server_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCServerVersionUpdated>(
                "CMsgGCServerVersionUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCServerVersionUpdated {
        static instance: ::protobuf::rt::LazyV2<CMsgGCServerVersionUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCServerVersionUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgGCServerVersionUpdated {
    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCServerVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCServerVersionUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientVersionUpdated {
    // message fields
    client_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientVersionUpdated {
    fn default() -> &'a CMsgGCClientVersionUpdated {
        <CMsgGCClientVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientVersionUpdated {
    pub fn new() -> CMsgGCClientVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClientVersionUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientVersionUpdated {
        CMsgGCClientVersionUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &CMsgGCClientVersionUpdated| { &m.client_version },
                |m: &mut CMsgGCClientVersionUpdated| { &mut m.client_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientVersionUpdated>(
                "CMsgGCClientVersionUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientVersionUpdated {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientVersionUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientVersionUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientVersionUpdated {
    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientVersionUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCWebAPIAccountChanged {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCWebAPIAccountChanged {
    fn default() -> &'a CMsgGCToGCWebAPIAccountChanged {
        <CMsgGCToGCWebAPIAccountChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCWebAPIAccountChanged {
    pub fn new() -> CMsgGCToGCWebAPIAccountChanged {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCToGCWebAPIAccountChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCWebAPIAccountChanged {
        CMsgGCToGCWebAPIAccountChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCWebAPIAccountChanged>(
                "CMsgGCToGCWebAPIAccountChanged",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCWebAPIAccountChanged {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCWebAPIAccountChanged> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCWebAPIAccountChanged::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCWebAPIAccountChanged {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCWebAPIAccountChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCWebAPIAccountChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCRequestPassportItemGrant {
    // message fields
    steam_id: ::std::option::Option<u64>,
    league_id: ::std::option::Option<u32>,
    reward_flag: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCRequestPassportItemGrant {
    fn default() -> &'a CMsgGCToGCRequestPassportItemGrant {
        <CMsgGCToGCRequestPassportItemGrant as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCRequestPassportItemGrant {
    pub fn new() -> CMsgGCToGCRequestPassportItemGrant {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;


    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }
    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional int32 reward_flag = 3;


    pub fn get_reward_flag(&self) -> i32 {
        self.reward_flag.unwrap_or(0)
    }
    pub fn clear_reward_flag(&mut self) {
        self.reward_flag = ::std::option::Option::None;
    }

    pub fn has_reward_flag(&self) -> bool {
        self.reward_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_flag(&mut self, v: i32) {
        self.reward_flag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCRequestPassportItemGrant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reward_flag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_flag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.reward_flag {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCRequestPassportItemGrant {
        CMsgGCToGCRequestPassportItemGrant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGCToGCRequestPassportItemGrant| { &m.steam_id },
                |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "league_id",
                |m: &CMsgGCToGCRequestPassportItemGrant| { &m.league_id },
                |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reward_flag",
                |m: &CMsgGCToGCRequestPassportItemGrant| { &m.reward_flag },
                |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.reward_flag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCRequestPassportItemGrant>(
                "CMsgGCToGCRequestPassportItemGrant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCRequestPassportItemGrant {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCRequestPassportItemGrant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCRequestPassportItemGrant::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCRequestPassportItemGrant {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.reward_flag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCRequestPassportItemGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCRequestPassportItemGrant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerInfo {
    // message fields
    server_public_ip_addr: ::std::option::Option<u32>,
    server_private_ip_addr: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    server_tv_port: ::std::option::Option<u32>,
    server_key: ::protobuf::SingularField<::std::string::String>,
    server_hibernation: ::std::option::Option<bool>,
    server_type: ::std::option::Option<CMsgGameServerInfo_ServerType>,
    server_region: ::std::option::Option<u32>,
    server_loadavg: ::std::option::Option<f32>,
    server_tv_broadcast_time: ::std::option::Option<f32>,
    server_game_time: ::std::option::Option<f32>,
    server_relay_connected_steam_id: ::std::option::Option<u64>,
    relay_slots_max: ::std::option::Option<u32>,
    relays_connected: ::std::option::Option<i32>,
    relay_clients_connected: ::std::option::Option<i32>,
    relayed_game_server_steam_id: ::std::option::Option<u64>,
    parent_relay_count: ::std::option::Option<u32>,
    tv_secret_code: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerInfo {
    fn default() -> &'a CMsgGameServerInfo {
        <CMsgGameServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerInfo {
    pub fn new() -> CMsgGameServerInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 server_public_ip_addr = 1;


    pub fn get_server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }
    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_private_ip_addr = 2;


    pub fn get_server_private_ip_addr(&self) -> u32 {
        self.server_private_ip_addr.unwrap_or(0)
    }
    pub fn clear_server_private_ip_addr(&mut self) {
        self.server_private_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_private_ip_addr(&self) -> bool {
        self.server_private_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_private_ip_addr(&mut self, v: u32) {
        self.server_private_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tv_port = 4;


    pub fn get_server_tv_port(&self) -> u32 {
        self.server_tv_port.unwrap_or(0)
    }
    pub fn clear_server_tv_port(&mut self) {
        self.server_tv_port = ::std::option::Option::None;
    }

    pub fn has_server_tv_port(&self) -> bool {
        self.server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_port(&mut self, v: u32) {
        self.server_tv_port = ::std::option::Option::Some(v);
    }

    // optional string server_key = 5;


    pub fn get_server_key(&self) -> &str {
        match self.server_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_key(&mut self) {
        self.server_key.clear();
    }

    pub fn has_server_key(&self) -> bool {
        self.server_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_key(&mut self, v: ::std::string::String) {
        self.server_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_key(&mut self) -> &mut ::std::string::String {
        if self.server_key.is_none() {
            self.server_key.set_default();
        }
        self.server_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_key(&mut self) -> ::std::string::String {
        self.server_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool server_hibernation = 6;


    pub fn get_server_hibernation(&self) -> bool {
        self.server_hibernation.unwrap_or(false)
    }
    pub fn clear_server_hibernation(&mut self) {
        self.server_hibernation = ::std::option::Option::None;
    }

    pub fn has_server_hibernation(&self) -> bool {
        self.server_hibernation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_hibernation(&mut self, v: bool) {
        self.server_hibernation = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerInfo.ServerType server_type = 7;


    pub fn get_server_type(&self) -> CMsgGameServerInfo_ServerType {
        self.server_type.unwrap_or(CMsgGameServerInfo_ServerType::UNSPECIFIED)
    }
    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: CMsgGameServerInfo_ServerType) {
        self.server_type = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 8;


    pub fn get_server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }
    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 9;


    pub fn get_server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }
    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional float server_tv_broadcast_time = 10;


    pub fn get_server_tv_broadcast_time(&self) -> f32 {
        self.server_tv_broadcast_time.unwrap_or(0.)
    }
    pub fn clear_server_tv_broadcast_time(&mut self) {
        self.server_tv_broadcast_time = ::std::option::Option::None;
    }

    pub fn has_server_tv_broadcast_time(&self) -> bool {
        self.server_tv_broadcast_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_broadcast_time(&mut self, v: f32) {
        self.server_tv_broadcast_time = ::std::option::Option::Some(v);
    }

    // optional float server_game_time = 11;


    pub fn get_server_game_time(&self) -> f32 {
        self.server_game_time.unwrap_or(0.)
    }
    pub fn clear_server_game_time(&mut self) {
        self.server_game_time = ::std::option::Option::None;
    }

    pub fn has_server_game_time(&self) -> bool {
        self.server_game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_game_time(&mut self, v: f32) {
        self.server_game_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_relay_connected_steam_id = 12;


    pub fn get_server_relay_connected_steam_id(&self) -> u64 {
        self.server_relay_connected_steam_id.unwrap_or(0)
    }
    pub fn clear_server_relay_connected_steam_id(&mut self) {
        self.server_relay_connected_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_relay_connected_steam_id(&self) -> bool {
        self.server_relay_connected_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_relay_connected_steam_id(&mut self, v: u64) {
        self.server_relay_connected_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_slots_max = 13;


    pub fn get_relay_slots_max(&self) -> u32 {
        self.relay_slots_max.unwrap_or(0)
    }
    pub fn clear_relay_slots_max(&mut self) {
        self.relay_slots_max = ::std::option::Option::None;
    }

    pub fn has_relay_slots_max(&self) -> bool {
        self.relay_slots_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_slots_max(&mut self, v: u32) {
        self.relay_slots_max = ::std::option::Option::Some(v);
    }

    // optional int32 relays_connected = 14;


    pub fn get_relays_connected(&self) -> i32 {
        self.relays_connected.unwrap_or(0)
    }
    pub fn clear_relays_connected(&mut self) {
        self.relays_connected = ::std::option::Option::None;
    }

    pub fn has_relays_connected(&self) -> bool {
        self.relays_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relays_connected(&mut self, v: i32) {
        self.relays_connected = ::std::option::Option::Some(v);
    }

    // optional int32 relay_clients_connected = 15;


    pub fn get_relay_clients_connected(&self) -> i32 {
        self.relay_clients_connected.unwrap_or(0)
    }
    pub fn clear_relay_clients_connected(&mut self) {
        self.relay_clients_connected = ::std::option::Option::None;
    }

    pub fn has_relay_clients_connected(&self) -> bool {
        self.relay_clients_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_clients_connected(&mut self, v: i32) {
        self.relay_clients_connected = ::std::option::Option::Some(v);
    }

    // optional fixed64 relayed_game_server_steam_id = 16;


    pub fn get_relayed_game_server_steam_id(&self) -> u64 {
        self.relayed_game_server_steam_id.unwrap_or(0)
    }
    pub fn clear_relayed_game_server_steam_id(&mut self) {
        self.relayed_game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_relayed_game_server_steam_id(&self) -> bool {
        self.relayed_game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relayed_game_server_steam_id(&mut self, v: u64) {
        self.relayed_game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_relay_count = 17;


    pub fn get_parent_relay_count(&self) -> u32 {
        self.parent_relay_count.unwrap_or(0)
    }
    pub fn clear_parent_relay_count(&mut self) {
        self.parent_relay_count = ::std::option::Option::None;
    }

    pub fn has_parent_relay_count(&self) -> bool {
        self.parent_relay_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_relay_count(&mut self, v: u32) {
        self.parent_relay_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_secret_code = 18;


    pub fn get_tv_secret_code(&self) -> u64 {
        self.tv_secret_code.unwrap_or(0)
    }
    pub fn clear_tv_secret_code(&mut self) {
        self.tv_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_secret_code(&self) -> bool {
        self.tv_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_secret_code(&mut self, v: u64) {
        self.tv_secret_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_public_ip_addr = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_private_ip_addr = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_tv_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_key)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.server_hibernation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.server_type, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_region = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_loadavg = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_tv_broadcast_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_game_time = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_relay_connected_steam_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_slots_max = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.relays_connected = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.relay_clients_connected = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.relayed_game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parent_relay_count = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.tv_secret_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_public_ip_addr {
            my_size += 5;
        }
        if let Some(v) = self.server_private_ip_addr {
            my_size += 5;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_tv_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_hibernation {
            my_size += 2;
        }
        if let Some(v) = self.server_type {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 5;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            my_size += 5;
        }
        if let Some(v) = self.server_game_time {
            my_size += 5;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.relay_slots_max {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relays_connected {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_clients_connected {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            my_size += 10;
        }
        if let Some(v) = self.parent_relay_count {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_secret_code {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_private_ip_addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_tv_port {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.server_key.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.server_hibernation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.server_type {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_game_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.relay_slots_max {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.relays_connected {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.relay_clients_connected {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            os.write_fixed64(16, v)?;
        }
        if let Some(v) = self.parent_relay_count {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_secret_code {
            os.write_fixed64(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerInfo {
        CMsgGameServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_public_ip_addr",
                |m: &CMsgGameServerInfo| { &m.server_public_ip_addr },
                |m: &mut CMsgGameServerInfo| { &mut m.server_public_ip_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_private_ip_addr",
                |m: &CMsgGameServerInfo| { &m.server_private_ip_addr },
                |m: &mut CMsgGameServerInfo| { &mut m.server_private_ip_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_port",
                |m: &CMsgGameServerInfo| { &m.server_port },
                |m: &mut CMsgGameServerInfo| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_tv_port",
                |m: &CMsgGameServerInfo| { &m.server_tv_port },
                |m: &mut CMsgGameServerInfo| { &mut m.server_tv_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_key",
                |m: &CMsgGameServerInfo| { &m.server_key },
                |m: &mut CMsgGameServerInfo| { &mut m.server_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "server_hibernation",
                |m: &CMsgGameServerInfo| { &m.server_hibernation },
                |m: &mut CMsgGameServerInfo| { &mut m.server_hibernation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerInfo_ServerType>>(
                "server_type",
                |m: &CMsgGameServerInfo| { &m.server_type },
                |m: &mut CMsgGameServerInfo| { &mut m.server_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_region",
                |m: &CMsgGameServerInfo| { &m.server_region },
                |m: &mut CMsgGameServerInfo| { &mut m.server_region },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "server_loadavg",
                |m: &CMsgGameServerInfo| { &m.server_loadavg },
                |m: &mut CMsgGameServerInfo| { &mut m.server_loadavg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "server_tv_broadcast_time",
                |m: &CMsgGameServerInfo| { &m.server_tv_broadcast_time },
                |m: &mut CMsgGameServerInfo| { &mut m.server_tv_broadcast_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "server_game_time",
                |m: &CMsgGameServerInfo| { &m.server_game_time },
                |m: &mut CMsgGameServerInfo| { &mut m.server_game_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "server_relay_connected_steam_id",
                |m: &CMsgGameServerInfo| { &m.server_relay_connected_steam_id },
                |m: &mut CMsgGameServerInfo| { &mut m.server_relay_connected_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_slots_max",
                |m: &CMsgGameServerInfo| { &m.relay_slots_max },
                |m: &mut CMsgGameServerInfo| { &mut m.relay_slots_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "relays_connected",
                |m: &CMsgGameServerInfo| { &m.relays_connected },
                |m: &mut CMsgGameServerInfo| { &mut m.relays_connected },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "relay_clients_connected",
                |m: &CMsgGameServerInfo| { &m.relay_clients_connected },
                |m: &mut CMsgGameServerInfo| { &mut m.relay_clients_connected },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "relayed_game_server_steam_id",
                |m: &CMsgGameServerInfo| { &m.relayed_game_server_steam_id },
                |m: &mut CMsgGameServerInfo| { &mut m.relayed_game_server_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "parent_relay_count",
                |m: &CMsgGameServerInfo| { &m.parent_relay_count },
                |m: &mut CMsgGameServerInfo| { &mut m.parent_relay_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "tv_secret_code",
                |m: &CMsgGameServerInfo| { &m.tv_secret_code },
                |m: &mut CMsgGameServerInfo| { &mut m.tv_secret_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerInfo>(
                "CMsgGameServerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerInfo::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerInfo {
    fn clear(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_private_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_tv_port = ::std::option::Option::None;
        self.server_key.clear();
        self.server_hibernation = ::std::option::Option::None;
        self.server_type = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_tv_broadcast_time = ::std::option::Option::None;
        self.server_game_time = ::std::option::Option::None;
        self.server_relay_connected_steam_id = ::std::option::Option::None;
        self.relay_slots_max = ::std::option::Option::None;
        self.relays_connected = ::std::option::Option::None;
        self.relay_clients_connected = ::std::option::Option::None;
        self.relayed_game_server_steam_id = ::std::option::Option::None;
        self.parent_relay_count = ::std::option::Option::None;
        self.tv_secret_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerInfo_ServerType {
    UNSPECIFIED = 0,
    GAME = 1,
    PROXY = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerInfo_ServerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerInfo_ServerType> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::UNSPECIFIED),
            1 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::GAME),
            2 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::PROXY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerInfo_ServerType] = &[
            CMsgGameServerInfo_ServerType::UNSPECIFIED,
            CMsgGameServerInfo_ServerType::GAME,
            CMsgGameServerInfo_ServerType::PROXY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGameServerInfo_ServerType>("CMsgGameServerInfo.ServerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGameServerInfo_ServerType {
}

impl ::std::default::Default for CMsgGameServerInfo_ServerType {
    fn default() -> Self {
        CMsgGameServerInfo_ServerType::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo_ServerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCBaseMsg {
    k_EMsgGCSystemMessage = 4001,
    k_EMsgGCReplicateConVars = 4002,
    k_EMsgGCConVarUpdated = 4003,
    k_EMsgGCInQueue = 4008,
    k_EMsgGCInviteToParty = 4501,
    k_EMsgGCInvitationCreated = 4502,
    k_EMsgGCPartyInviteResponse = 4503,
    k_EMsgGCKickFromParty = 4504,
    k_EMsgGCLeaveParty = 4505,
    k_EMsgGCServerAvailable = 4506,
    k_EMsgGCClientConnectToServer = 4507,
    k_EMsgGCGameServerInfo = 4508,
    k_EMsgGCError = 4509,
    k_EMsgGCReplay_UploadedToYouTube = 4510,
    k_EMsgGCLANServerAvailable = 4511,
}

impl ::protobuf::ProtobufEnum for EGCBaseMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4001 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4008 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInQueue),
            4501 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            4502 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            4503 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            4504 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            4505 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4509 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            4510 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCBaseMsg] = &[
            EGCBaseMsg::k_EMsgGCSystemMessage,
            EGCBaseMsg::k_EMsgGCReplicateConVars,
            EGCBaseMsg::k_EMsgGCConVarUpdated,
            EGCBaseMsg::k_EMsgGCInQueue,
            EGCBaseMsg::k_EMsgGCInviteToParty,
            EGCBaseMsg::k_EMsgGCInvitationCreated,
            EGCBaseMsg::k_EMsgGCPartyInviteResponse,
            EGCBaseMsg::k_EMsgGCKickFromParty,
            EGCBaseMsg::k_EMsgGCLeaveParty,
            EGCBaseMsg::k_EMsgGCServerAvailable,
            EGCBaseMsg::k_EMsgGCClientConnectToServer,
            EGCBaseMsg::k_EMsgGCGameServerInfo,
            EGCBaseMsg::k_EMsgGCError,
            EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube,
            EGCBaseMsg::k_EMsgGCLANServerAvailable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCBaseMsg>("EGCBaseMsg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCBaseMsg {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCSystemMessage
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCBaseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCBaseProtoObjectTypes {
    k_EProtoObjectPartyInvite = 1001,
    k_EProtoObjectLobbyInvite = 1002,
}

impl ::protobuf::ProtobufEnum for EGCBaseProtoObjectTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match value {
            1001 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            1002 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCBaseProtoObjectTypes] = &[
            EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite,
            EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCBaseProtoObjectTypes>("EGCBaseProtoObjectTypes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCBaseProtoObjectTypes {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseProtoObjectTypes {
    fn default() -> Self {
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCBaseProtoObjectTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GC_BannedWordType {
    GC_BANNED_WORD_DISABLE_WORD = 0,
    GC_BANNED_WORD_ENABLE_WORD = 1,
}

impl ::protobuf::ProtobufEnum for GC_BannedWordType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GC_BannedWordType> {
        match value {
            0 => ::std::option::Option::Some(GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD),
            1 => ::std::option::Option::Some(GC_BannedWordType::GC_BANNED_WORD_ENABLE_WORD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GC_BannedWordType] = &[
            GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD,
            GC_BannedWordType::GC_BANNED_WORD_ENABLE_WORD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GC_BannedWordType>("GC_BannedWordType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GC_BannedWordType {
}

impl ::std::default::Default for GC_BannedWordType {
    fn default() -> Self {
        GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD
    }
}

impl ::protobuf::reflect::ProtobufValue for GC_BannedWordType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15base_gcmessages.proto\x1a\x13steammessages.proto\"\xb5\x01\n\x1dCG\
    CStorePurchaseInit_LineItem\x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\rR\
    \titemDefId\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\x123\n\
    \x16cost_in_local_currency\x18\x03\x20\x01(\rR\x13costInLocalCurrency\
    \x12#\n\rpurchase_type\x18\x04\x20\x01(\rR\x0cpurchaseType\"\xaa\x01\n\
    \x17CMsgGCStorePurchaseInit\x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07\
    country\x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\x12\x1a\
    \n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12=\n\nline_items\x18\
    \x04\x20\x03(\x0b2\x1e.CGCStorePurchaseInit_LineItemR\tlineItems\"}\n\
    \x1fCMsgGCStorePurchaseInitResponse\x12\x16\n\x06result\x18\x01\x20\x01(\
    \x05R\x06result\x12\x15\n\x06txn_id\x18\x02\x20\x01(\x04R\x05txnId\x12\
    \x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\x19\n\x08item_ids\x18\x04\
    \x20\x03(\x04R\x07itemIds\"o\n\x0eCSOPartyInvite\x12\x1f\n\x08group_id\
    \x18\x01\x20\x01(\x04R\x07groupIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tsender\
    _id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bsender_name\x18\x03\
    \x20\x01(\tR\nsenderName\"o\n\x0eCSOLobbyInvite\x12\x1f\n\x08group_id\
    \x18\x01\x20\x01(\x04R\x07groupIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tsender\
    _id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bsender_name\x18\x03\
    \x20\x01(\tR\nsenderName\"/\n\x13CMsgSystemBroadcast\x12\x18\n\x07messag\
    e\x18\x01\x20\x01(\tR\x07message\"v\n\x11CMsgInviteToParty\x12\x19\n\x08\
    steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12%\n\x0eclient_version\x18\
    \x02\x20\x01(\rR\rclientVersion\x12\x1f\n\x0bteam_invite\x18\x03\x20\x01\
    (\rR\nteamInvite\"M\n\x15CMsgInvitationCreated\x12\x19\n\x08group_id\x18\
    \x01\x20\x01(\x04R\x07groupId\x12\x19\n\x08steam_id\x18\x02\x20\x01(\x06\
    R\x07steamId\"\x94\x01\n\x17CMsgPartyInviteResponse\x12\x19\n\x08party_i\
    d\x18\x01\x20\x01(\x04R\x07partyId\x12\x16\n\x06accept\x18\x02\x20\x01(\
    \x08R\x06accept\x12%\n\x0eclient_version\x18\x03\x20\x01(\rR\rclientVers\
    ion\x12\x1f\n\x0bteam_invite\x18\x04\x20\x01(\rR\nteamInvite\".\n\x11CMs\
    gKickFromParty\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\
    \x10\n\x0eCMsgLeaveParty\"\x15\n\x13CMsgServerAvailable\"3\n\x16CMsgLANS\
    erverAvailable\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\"\
    \x9a\x02\n\x18CSOEconGameAccountClient\x12=\n\x19additional_backpack_slo\
    ts\x18\x01\x20\x01(\r:\x010R\x17additionalBackpackSlots\x12;\n\x1abonus_\
    xp_timestamp_refresh\x18\x0c\x20\x01(\x07R\x17bonusXpTimestampRefresh\
    \x12,\n\x12bonus_xp_usedflags\x18\r\x20\x01(\rR\x10bonusXpUsedflags\x12%\
    \n\x0eelevated_state\x18\x0e\x20\x01(\rR\relevatedState\x12-\n\x12elevat\
    ed_timestamp\x18\x0f\x20\x01(\rR\x11elevatedTimestamp\"\xa0\x01\n\x18CSO\
    ItemCriteriaCondition\x12\x0e\n\x02op\x18\x01\x20\x01(\x05R\x02op\x12\
    \x14\n\x05field\x18\x02\x20\x01(\tR\x05field\x12\x1a\n\x08required\x18\
    \x03\x20\x01(\x08R\x08required\x12\x1f\n\x0bfloat_value\x18\x04\x20\x01(\
    \x02R\nfloatValue\x12!\n\x0cstring_value\x18\x05\x20\x01(\tR\x0bstringVa\
    lue\"\xd0\x03\n\x0fCSOItemCriteria\x12\x1d\n\nitem_level\x18\x01\x20\x01\
    (\rR\titemLevel\x12!\n\x0citem_quality\x18\x02\x20\x01(\x05R\x0bitemQual\
    ity\x12$\n\x0eitem_level_set\x18\x03\x20\x01(\x08R\x0citemLevelSet\x12(\
    \n\x10item_quality_set\x18\x04\x20\x01(\x08R\x0eitemQualitySet\x12+\n\
    \x11initial_inventory\x18\x05\x20\x01(\rR\x10initialInventory\x12)\n\x10\
    initial_quantity\x18\x06\x20\x01(\rR\x0finitialQuantity\x12.\n\x13ignore\
    _enabled_flag\x18\x08\x20\x01(\x08R\x11ignoreEnabledFlag\x129\n\nconditi\
    ons\x18\t\x20\x03(\x0b2\x19.CSOItemCriteriaConditionR\nconditions\x12\
    \x1f\n\x0bitem_rarity\x18\n\x20\x01(\x05R\nitemRarity\x12&\n\x0fitem_rar\
    ity_set\x18\x0b\x20\x01(\x08R\ritemRaritySet\x12\x1f\n\x0brecent_only\
    \x18\x0c\x20\x01(\x08R\nrecentOnly\"\xc0\x05\n\rCSOItemRecipe\x12\x1b\n\
    \tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x0f\n\x03n_a\x18\x03\x20\x01(\tR\x02nA\x12\x1f\
    \n\x0bdesc_inputs\x18\x04\x20\x01(\tR\ndescInputs\x12!\n\x0cdesc_outputs\
    \x18\x05\x20\x01(\tR\x0bdescOutputs\x12\x11\n\x04di_a\x18\x06\x20\x01(\t\
    R\x03diA\x12\x11\n\x04di_b\x18\x07\x20\x01(\tR\x03diB\x12\x11\n\x04di_c\
    \x18\x08\x20\x01(\tR\x03diC\x12\x11\n\x04do_a\x18\t\x20\x01(\tR\x03doA\
    \x12\x11\n\x04do_b\x18\n\x20\x01(\tR\x03doB\x12\x11\n\x04do_c\x18\x0b\
    \x20\x01(\tR\x03doC\x125\n\x17requires_all_same_class\x18\x0c\x20\x01(\
    \x08R\x14requiresAllSameClass\x123\n\x16requires_all_same_slot\x18\r\x20\
    \x01(\x08R\x13requiresAllSameSlot\x123\n\x16class_usage_for_output\x18\
    \x0e\x20\x01(\x05R\x13classUsageForOutput\x121\n\x15slot_usage_for_outpu\
    t\x18\x0f\x20\x01(\x05R\x12slotUsageForOutput\x12$\n\x0eset_for_output\
    \x18\x10\x20\x01(\x05R\x0csetForOutput\x12B\n\x14input_items_criteria\
    \x18\x14\x20\x03(\x0b2\x10.CSOItemCriteriaR\x12inputItemsCriteria\x12D\n\
    \x15output_items_criteria\x18\x15\x20\x03(\x0b2\x10.CSOItemCriteriaR\x13\
    outputItemsCriteria\x123\n\x16input_item_dupe_counts\x18\x16\x20\x03(\rR\
    \x13inputItemDupeCounts\"a\n\x15CMsgDevNewItemRequest\x12\x1a\n\x08recei\
    ver\x18\x01\x20\x01(\x06R\x08receiver\x12,\n\x08criteria\x18\x02\x20\x01\
    (\x0b2\x10.CSOItemCriteriaR\x08criteria\"\xc9\x01\n\x1fCMsgIncrementKill\
    CountAttribute\x12*\n\x11killer_account_id\x18\x01\x20\x01(\x07R\x0fkill\
    erAccountId\x12*\n\x11victim_account_id\x18\x02\x20\x01(\x07R\x0fvictimA\
    ccountId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\x12\x1d\n\
    \nevent_type\x18\x04\x20\x01(\rR\teventType\x12\x16\n\x06amount\x18\x05\
    \x20\x01(\rR\x06amount\"\xcb\x01\n\x10CMsgApplySticker\x12&\n\x0fsticker\
    _item_id\x18\x01\x20\x01(\x04R\rstickerItemId\x12\x20\n\x0citem_item_id\
    \x18\x02\x20\x01(\x04R\nitemItemId\x12!\n\x0csticker_slot\x18\x03\x20\
    \x01(\rR\x0bstickerSlot\x12'\n\x0fbaseitem_defidx\x18\x04\x20\x01(\rR\
    \x0ebaseitemDefidx\x12!\n\x0csticker_wear\x18\x05\x20\x01(\x02R\x0bstick\
    erWear\"r\n\x17CMsgModifyItemAttribute\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x12\x1f\n\x0battr_defidx\x18\x02\x20\x01(\rR\nattrD\
    efidx\x12\x1d\n\nattr_value\x18\x03\x20\x01(\rR\tattrValue\"\x83\x01\n\
    \x15CMsgApplyStatTrakSwap\x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04\
    R\ntoolItemId\x12#\n\x0eitem_1_item_id\x18\x02\x20\x01(\x04R\x0bitem1Ite\
    mId\x12#\n\x0eitem_2_item_id\x18\x03\x20\x01(\x04R\x0bitem2ItemId\"i\n\
    \x14CMsgApplyStrangePart\x12/\n\x14strange_part_item_id\x18\x01\x20\x01(\
    \x04R\x11strangePartItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\
    \x04R\nitemItemId\"i\n\x17CMsgApplyPennantUpgrade\x12&\n\x0fupgrade_item\
    _id\x18\x01\x20\x01(\x04R\rupgradeItemId\x12&\n\x0fpennant_item_id\x18\
    \x02\x20\x01(\x04R\rpennantItemId\"]\n\x13CMsgApplyEggEssence\x12&\n\x0f\
    essence_item_id\x18\x01\x20\x01(\x04R\ressenceItemId\x12\x1e\n\x0begg_it\
    em_id\x18\x02\x20\x01(\x04R\teggItemId\"j\n\x14CSOEconItemAttribute\x12\
    \x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x14\n\x05value\x18\
    \x02\x20\x01(\rR\x05value\x12\x1f\n\x0bvalue_bytes\x18\x03\x20\x01(\x0cR\
    \nvalueBytes\"M\n\x13CSOEconItemEquipped\x12\x1b\n\tnew_class\x18\x01\
    \x20\x01(\rR\x08newClass\x12\x19\n\x08new_slot\x18\x02\x20\x01(\rR\x07ne\
    wSlot\"\xce\x04\n\x0bCSOEconItem\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\
    \x02id\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1c\n\ti\
    nventory\x18\x03\x20\x01(\rR\tinventory\x12\x1b\n\tdef_index\x18\x04\x20\
    \x01(\rR\x08defIndex\x12\x1a\n\x08quantity\x18\x05\x20\x01(\rR\x08quanti\
    ty\x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05level\x12\x18\n\x07quality\
    \x18\x07\x20\x01(\rR\x07quality\x12\x17\n\x05flags\x18\x08\x20\x01(\r:\
    \x010R\x05flags\x12\x16\n\x06origin\x18\t\x20\x01(\rR\x06origin\x12\x1f\
    \n\x0bcustom_name\x18\n\x20\x01(\tR\ncustomName\x12\x1f\n\x0bcustom_desc\
    \x18\x0b\x20\x01(\tR\ncustomDesc\x123\n\tattribute\x18\x0c\x20\x03(\x0b2\
    \x15.CSOEconItemAttributeR\tattribute\x121\n\rinterior_item\x18\r\x20\
    \x01(\x0b2\x0c.CSOEconItemR\x0cinteriorItem\x12\x1c\n\x06in_use\x18\x0e\
    \x20\x01(\x08:\x05falseR\x05inUse\x12\x17\n\x05style\x18\x0f\x20\x01(\r:\
    \x010R\x05style\x12\"\n\x0boriginal_id\x18\x10\x20\x01(\x04:\x010R\norig\
    inalId\x12;\n\x0eequipped_state\x18\x12\x20\x03(\x0b2\x14.CSOEconItemEqu\
    ippedR\requippedState\x12\x16\n\x06rarity\x18\x13\x20\x01(\rR\x06rarity\
    \"\x82\x01\n\x1bCMsgAdjustItemEquippedState\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x04R\x06itemId\x12\x1b\n\tnew_class\x18\x02\x20\x01(\rR\x08new\
    Class\x12\x19\n\x08new_slot\x18\x03\x20\x01(\rR\x07newSlot\x12\x12\n\x04\
    swap\x18\x04\x20\x01(\x08R\x04swap\"\x7f\n\x20CMsgAdjustItemEquippedStat\
    eMulti\x12\x19\n\x08t_equips\x18\x01\x20\x03(\x04R\x07tEquips\x12\x1b\n\
    \tct_equips\x18\x02\x20\x03(\x04R\x08ctEquips\x12#\n\rnoteam_equips\x18\
    \x03\x20\x03(\x04R\x0cnoteamEquips\",\n\rCMsgSortItems\x12\x1b\n\tsort_t\
    ype\x18\x01\x20\x01(\rR\x08sortType\"\x87\x01\n\x10CSOEconClaimCode\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1b\n\tcode_type\
    \x18\x02\x20\x01(\rR\x08codeType\x12#\n\rtime_acquired\x18\x03\x20\x01(\
    \rR\x0ctimeAcquired\x12\x12\n\x04code\x18\x04\x20\x01(\tR\x04code\"b\n\
    \x14CMsgStoreGetUserData\x12.\n\x13price_sheet_version\x18\x01\x20\x01(\
    \x07R\x11priceSheetVersion\x12\x1a\n\x08currency\x18\x02\x20\x01(\x05R\
    \x08currency\"\xe7\x01\n\x1cCMsgStoreGetUserDataResponse\x12\x16\n\x06re\
    sult\x18\x01\x20\x01(\x05R\x06result\x12/\n\x13currency_deprecated\x18\
    \x02\x20\x01(\x05R\x12currencyDeprecated\x12-\n\x12country_deprecated\
    \x18\x03\x20\x01(\tR\x11countryDeprecated\x12.\n\x13price_sheet_version\
    \x18\x04\x20\x01(\x07R\x11priceSheetVersion\x12\x1f\n\x0bprice_sheet\x18\
    \x08\x20\x01(\x0cR\npriceSheet\"\xce\x01\n\x14CMsgUpdateItemSchema\x12\
    \x1d\n\nitems_game\x18\x01\x20\x01(\x0cR\titemsGame\x12.\n\x13item_schem\
    a_version\x18\x02\x20\x01(\x07R\x11itemSchemaVersion\x12A\n\x1ditems_gam\
    e_url_DEPRECATED2013\x18\x03\x20\x01(\tR\x1aitemsGameUrlDEPRECATED2013\
    \x12$\n\x0eitems_game_url\x18\x04\x20\x01(\tR\x0citemsGameUrl\",\n\x0bCM\
    sgGCError\x12\x1d\n\nerror_text\x18\x01\x20\x01(\tR\terrorText\"\x1d\n\
    \x1bCMsgRequestInventoryRefresh\";\n\x0fCMsgConVarValue\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value\"B\n\x14CMsgReplicateConVars\x12*\n\x07convars\x18\x01\x20\x03(\
    \x0b2\x10.CMsgConVarValueR\x07convars\"\xdc\x01\n\x0bCMsgUseItem\x12\x17\
    \n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12&\n\x0ftarget_steam_id\
    \x18\x02\x20\x01(\x06R\rtargetSteamId\x125\n\x17gift__potential_targets\
    \x18\x03\x20\x03(\rR\x14giftPotentialTargets\x12'\n\x10duel__class_lock\
    \x18\x04\x20\x01(\rR\rduelClassLock\x12,\n\x12initiator_steam_id\x18\x05\
    \x20\x01(\x06R\x10initiatorSteamId\"\x8f\x01\n\x1bCMsgReplayUploadedToYo\
    uTube\x12\x1f\n\x0byoutube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x120\n\
    \x14youtube_account_name\x18\x02\x20\x01(\tR\x12youtubeAccountName\x12\
    \x1d\n\nsession_id\x18\x03\x20\x01(\x04R\tsessionId\"9\n\x17CMsgConsumab\
    leExhausted\x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\x05R\titemDefId\"\
    \xdf\x01\n\x20CMsgItemAcknowledged__DEPRECATED\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x1c\n\tinventory\x18\x02\x20\x01(\rR\tin\
    ventory\x12\x1b\n\tdef_index\x18\x03\x20\x01(\rR\x08defIndex\x12\x18\n\
    \x07quality\x18\x04\x20\x01(\rR\x07quality\x12\x16\n\x06rarity\x18\x05\
    \x20\x01(\rR\x06rarity\x12\x16\n\x06origin\x18\x06\x20\x01(\rR\x06origin\
    \x12\x17\n\x07item_id\x18\x07\x20\x01(\x04R\x06itemId\"\xcc\x01\n\x14CMs\
    gSetItemPositions\x12I\n\x0eitem_positions\x18\x01\x20\x03(\x0b2\".CMsgS\
    etItemPositions.ItemPositionR\ritemPositions\x1ai\n\x0cItemPosition\x12$\
    \n\x0elegacy_item_id\x18\x01\x20\x01(\rR\x0clegacyItemId\x12\x1a\n\x08po\
    sition\x18\x02\x20\x01(\rR\x08position\x12\x17\n\x07item_id\x18\x03\x20\
    \x01(\x04R\x06itemId\"\x9b\x02\n\x11CMsgGCReportAbuse\x12&\n\x0ftarget_s\
    team_id\x18\x01\x20\x01(\x06R\rtargetSteamId\x12\x20\n\x0bdescription\
    \x18\x04\x20\x01(\tR\x0bdescription\x12\x10\n\x03gid\x18\x05\x20\x01(\
    \x04R\x03gid\x12\x1d\n\nabuse_type\x18\x02\x20\x01(\rR\tabuseType\x12!\n\
    \x0ccontent_type\x18\x03\x20\x01(\rR\x0bcontentType\x121\n\x15target_gam\
    e_server_ip\x18\x06\x20\x01(\x07R\x12targetGameServerIp\x125\n\x17target\
    _game_server_port\x18\x07\x20\x01(\rR\x14targetGameServerPort\"\x80\x01\
    \n\x19CMsgGCReportAbuseResponse\x12&\n\x0ftarget_steam_id\x18\x01\x20\
    \x01(\x06R\rtargetSteamId\x12\x16\n\x06result\x18\x02\x20\x01(\rR\x06res\
    ult\x12#\n\rerror_message\x18\x03\x20\x01(\tR\x0cerrorMessage\"\x93\x01\
    \n\x1aCMsgGCNameItemNotification\x12%\n\x0eplayer_steamid\x18\x01\x20\
    \x01(\x06R\rplayerSteamid\x12$\n\x0eitem_def_index\x18\x02\x20\x01(\rR\
    \x0citemDefIndex\x12(\n\x10item_name_custom\x18\x03\x20\x01(\tR\x0eitemN\
    ameCustom\"\xa1\x02\n\x1fCMsgGCClientDisplayNotification\x12M\n#notifica\
    tion_title_localization_key\x18\x01\x20\x01(\tR\x20notificationTitleLoca\
    lizationKey\x12K\n\"notification_body_localization_key\x18\x02\x20\x01(\
    \tR\x1fnotificationBodyLocalizationKey\x12.\n\x13body_substring_keys\x18\
    \x03\x20\x03(\tR\x11bodySubstringKeys\x122\n\x15body_substring_values\
    \x18\x04\x20\x03(\tR\x13bodySubstringValues\"@\n\x17CMsgGCShowItemsPicke\
    dUp\x12%\n\x0eplayer_steamid\x18\x01\x20\x01(\x06R\rplayerSteamid\"\xab\
    \x01\n\x20CMsgGCIncrementKillCountResponse\x120\n\x11killer_account_id\
    \x18\x01\x20\x01(\rR\x0fkillerAccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\t\
    num_kills\x18\x02\x20\x01(\rR\x08numKills\x12\x19\n\x08item_def\x18\x03\
    \x20\x01(\rR\x07itemDef\x12\x1d\n\nlevel_type\x18\x04\x20\x01(\rR\tlevel\
    Type\"\xcf\x01\n\x18CSOEconItemDropRateBonus\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12'\n\x0fexpiration_date\x18\x02\x20\x01(\
    \x07R\x0eexpirationDate\x12\x14\n\x05bonus\x18\x03\x20\x01(\x02R\x05bonu\
    s\x12\x1f\n\x0bbonus_count\x18\x04\x20\x01(\rR\nbonusCount\x12\x17\n\x07\
    item_id\x18\x05\x20\x01(\x04R\x06itemId\x12\x1b\n\tdef_index\x18\x06\x20\
    \x01(\rR\x08defIndex\"\x97\x01\n\x19CSOEconItemLeagueViewPass\x12#\n\nac\
    count_id\x18\x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12!\n\tlea\
    gue_id\x18\x02\x20\x01(\rR\x08leagueIdB\x04\x80\xa6\x1d\x01\x12\x14\n\
    \x05admin\x18\x03\x20\x01(\rR\x05admin\x12\x1c\n\titemindex\x18\x04\x20\
    \x01(\rR\titemindex\"k\n\x16CSOEconItemEventTicket\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08event_id\x18\x02\x20\x01(\r\
    R\x07eventId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\"O\n'C\
    MsgGCItemPreviewItemBoughtNotification\x12$\n\x0eitem_def_index\x18\x01\
    \x20\x01(\rR\x0citemDefIndex\"2\n\x19CMsgGCStorePurchaseCancel\x12\x15\n\
    \x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\";\n!CMsgGCStorePurchaseCancel\
    Response\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"4\n\x1bCMsgG\
    CStorePurchaseFinalize\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\x05txnI\
    d\"X\n#CMsgGCStorePurchaseFinalizeResponse\x12\x16\n\x06result\x18\x01\
    \x20\x01(\rR\x06result\x12\x19\n\x08item_ids\x18\x02\x20\x03(\x04R\x07it\
    emIds\"a\n\x1bCMsgGCBannedWordListRequest\x12)\n\x11ban_list_group_id\
    \x18\x01\x20\x01(\rR\x0ebanListGroupId\x12\x17\n\x07word_id\x18\x02\x20\
    \x01(\rR\x06wordId\"\x1c\n\x1aCMsgGCRequestAnnouncements\"\xbe\x01\n\"CM\
    sgGCRequestAnnouncementsResponse\x12-\n\x12announcement_title\x18\x01\
    \x20\x01(\tR\x11announcementTitle\x12\"\n\x0cannouncement\x18\x02\x20\
    \x01(\tR\x0cannouncement\x12'\n\x0fnextmatch_title\x18\x03\x20\x01(\tR\
    \x0enextmatchTitle\x12\x1c\n\tnextmatch\x18\x04\x20\x01(\tR\tnextmatch\"\
    \x8d\x01\n\x10CMsgGCBannedWord\x12\x17\n\x07word_id\x18\x01\x20\x01(\rR\
    \x06wordId\x12L\n\tword_type\x18\x02\x20\x01(\x0e2\x12.GC_BannedWordType\
    :\x1bGC_BANNED_WORD_DISABLE_WORDR\x08wordType\x12\x12\n\x04word\x18\x03\
    \x20\x01(\tR\x04word\"y\n\x1cCMsgGCBannedWordListResponse\x12)\n\x11ban_\
    list_group_id\x18\x01\x20\x01(\rR\x0ebanListGroupId\x12.\n\tword_list\
    \x18\x02\x20\x03(\x0b2\x11.CMsgGCBannedWordR\x08wordList\"`\n!CMsgGCToGC\
    BannedWordListBroadcast\x12;\n\tbroadcast\x18\x01\x20\x01(\x0b2\x1d.CMsg\
    GCBannedWordListResponseR\tbroadcast\"<\n\x1fCMsgGCToGCBannedWordListUpd\
    ated\x12\x19\n\x08group_id\x18\x01\x20\x01(\rR\x07groupId\"\xbe\x01\n.CS\
    OEconDefaultEquippedDefinitionInstanceClient\x12#\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12'\n\x0fitem_definition\
    \x18\x02\x20\x01(\rR\x0eitemDefinition\x12\x1f\n\x08class_id\x18\x03\x20\
    \x01(\rR\x07classIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07slot_id\x18\x04\
    \x20\x01(\rR\x06slotIdB\x04\x80\xa6\x1d\x01\"S\n\x17CMsgGCToGCDirtySDOCa\
    che\x12\x19\n\x08sdo_type\x18\x01\x20\x01(\rR\x07sdoType\x12\x1d\n\nkey_\
    uint64\x18\x02\x20\x01(\x04R\tkeyUint64\"[\n\x1fCMsgGCToGCDirtyMultipleS\
    DOCache\x12\x19\n\x08sdo_type\x18\x01\x20\x01(\rR\x07sdoType\x12\x1d\n\n\
    key_uint64\x18\x02\x20\x03(\x04R\tkeyUint64\"i\n\x11CMsgGCCollectItem\
    \x12,\n\x12collection_item_id\x18\x01\x20\x01(\x04R\x10collectionItemId\
    \x12&\n\x0fsubject_item_id\x18\x02\x20\x01(\x04R\rsubjectItemId\"\x14\n\
    \x12CMsgSDONoMemcached\"8\n\x1bCMsgGCToGCUpdateSQLKeyValue\x12\x19\n\x08\
    key_name\x18\x01\x20\x01(\tR\x07keyName\"6\n\x19CMsgGCToGCIsTrustedServe\
    r\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"B\n!CMsgGCToGC\
    IsTrustedServerResponse\x12\x1d\n\nis_trusted\x18\x01\x20\x01(\x08R\tisT\
    rusted\"D\n!CMsgGCToGCBroadcastConsoleCommand\x12\x1f\n\x0bcon_command\
    \x18\x01\x20\x01(\tR\nconCommand\"C\n\x1aCMsgGCServerVersionUpdated\x12%\
    \n\x0eserver_version\x18\x01\x20\x01(\rR\rserverVersion\"C\n\x1aCMsgGCCl\
    ientVersionUpdated\x12%\n\x0eclient_version\x18\x01\x20\x01(\rR\rclientV\
    ersion\"\x20\n\x1eCMsgGCToGCWebAPIAccountChanged\"}\n\"CMsgGCToGCRequest\
    PassportItemGrant\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\
    \x12\x1b\n\tleague_id\x18\x02\x20\x01(\rR\x08leagueId\x12\x1f\n\x0brewar\
    d_flag\x18\x03\x20\x01(\x05R\nrewardFlag\"\xa7\x07\n\x12CMsgGameServerIn\
    fo\x121\n\x15server_public_ip_addr\x18\x01\x20\x01(\x07R\x12serverPublic\
    IpAddr\x123\n\x16server_private_ip_addr\x18\x02\x20\x01(\x07R\x13serverP\
    rivateIpAddr\x12\x1f\n\x0bserver_port\x18\x03\x20\x01(\rR\nserverPort\
    \x12$\n\x0eserver_tv_port\x18\x04\x20\x01(\rR\x0cserverTvPort\x12\x1d\n\
    \nserver_key\x18\x05\x20\x01(\tR\tserverKey\x12-\n\x12server_hibernation\
    \x18\x06\x20\x01(\x08R\x11serverHibernation\x12L\n\x0bserver_type\x18\
    \x07\x20\x01(\x0e2\x1e.CMsgGameServerInfo.ServerType:\x0bUNSPECIFIEDR\ns\
    erverType\x12#\n\rserver_region\x18\x08\x20\x01(\rR\x0cserverRegion\x12%\
    \n\x0eserver_loadavg\x18\t\x20\x01(\x02R\rserverLoadavg\x127\n\x18server\
    _tv_broadcast_time\x18\n\x20\x01(\x02R\x15serverTvBroadcastTime\x12(\n\
    \x10server_game_time\x18\x0b\x20\x01(\x02R\x0eserverGameTime\x12D\n\x1fs\
    erver_relay_connected_steam_id\x18\x0c\x20\x01(\x06R\x1bserverRelayConne\
    ctedSteamId\x12&\n\x0frelay_slots_max\x18\r\x20\x01(\rR\rrelaySlotsMax\
    \x12)\n\x10relays_connected\x18\x0e\x20\x01(\x05R\x0frelaysConnected\x12\
    6\n\x17relay_clients_connected\x18\x0f\x20\x01(\x05R\x15relayClientsConn\
    ected\x12>\n\x1crelayed_game_server_steam_id\x18\x10\x20\x01(\x06R\x18re\
    layedGameServerSteamId\x12,\n\x12parent_relay_count\x18\x11\x20\x01(\rR\
    \x10parentRelayCount\x12$\n\x0etv_secret_code\x18\x12\x20\x01(\x06R\x0ct\
    vSecretCode\"2\n\nServerType\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\n\
    \x04GAME\x10\x01\x12\t\n\x05PROXY\x10\x02*\xc7\x03\n\nEGCBaseMsg\x12\x1a\
    \n\x15k_EMsgGCSystemMessage\x10\xa1\x1f\x12\x1d\n\x18k_EMsgGCReplicateCo\
    nVars\x10\xa2\x1f\x12\x1a\n\x15k_EMsgGCConVarUpdated\x10\xa3\x1f\x12\x14\
    \n\x0fk_EMsgGCInQueue\x10\xa8\x1f\x12\x1a\n\x15k_EMsgGCInviteToParty\x10\
    \x95#\x12\x1e\n\x19k_EMsgGCInvitationCreated\x10\x96#\x12\x20\n\x1bk_EMs\
    gGCPartyInviteResponse\x10\x97#\x12\x1a\n\x15k_EMsgGCKickFromParty\x10\
    \x98#\x12\x17\n\x12k_EMsgGCLeaveParty\x10\x99#\x12\x1c\n\x17k_EMsgGCServ\
    erAvailable\x10\x9a#\x12\"\n\x1dk_EMsgGCClientConnectToServer\x10\x9b#\
    \x12\x1b\n\x16k_EMsgGCGameServerInfo\x10\x9c#\x12\x12\n\rk_EMsgGCError\
    \x10\x9d#\x12%\n\x20k_EMsgGCReplay_UploadedToYouTube\x10\x9e#\x12\x1f\n\
    \x1ak_EMsgGCLANServerAvailable\x10\x9f#*Y\n\x17EGCBaseProtoObjectTypes\
    \x12\x1e\n\x19k_EProtoObjectPartyInvite\x10\xe9\x07\x12\x1e\n\x19k_EProt\
    oObjectLobbyInvite\x10\xea\x07*T\n\x11GC_BannedWordType\x12\x1f\n\x1bGC_\
    BANNED_WORD_DISABLE_WORD\x10\0\x12\x1e\n\x1aGC_BANNED_WORD_ENABLE_WORD\
    \x10\x01B\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
